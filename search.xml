<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端文件及二进制相关]]></title>
    <url>%2FBlog%2F2020%2F08%2F05%2Fbinary%2F</url>
    <content type="text"><![CDATA[关系图 FileReader APIFileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。 其中File对象可以是来自用户在一个input元素上选择文件后返回的FileList对象,也可以来自拖放操作生成的 DataTransfer对象,还可以是来自在一个HTMLCanvasElement上执行mozGetAsFile()方法后返回结果。 重要提示： FileReader仅用于以安全的方式从用户（远程）系统读取文件内容 它不能用于从文件系统中按路径名简单地读取文件。 要在JavaScript中按路径名读取文件，应使用标准Ajax解决方案进行服务器端文件读取，如果读取跨域，则使用CORS权限。 FileReader兼容性 FileReader API FileReader 实例 URL APIURL.createObjectURL() 静态方法会创建一个 DOMString，其中包含一个表示参数中给出的对象的URL。这个 URL 的生命周期和创建它的窗口中的 document 绑定。这个新的URL 对象表示指定的 File 对象或 Blob 对象。 URL.createObjectURL() 12345/** * object * 用于创建 URL 的 File 对象、Blob 对象或者 MediaSource 对象。​**/var objectURL = URL.createObjectURL(object); URL.revokeObjectURL() 静态方法用来释放一个之前已经存在的、通过调用 URL.createObjectURL() 创建的 URL 对象。当你结束使用某个 URL 对象之后，应该通过调用这个方法来让浏览器知道不用在内存中继续保留对这个文件的引用了。 你可以在 sourceopen 被处理之后的任何时候调用 revokeObjectURL()。这是因为 createObjectURL() 仅仅意味着将一个媒体元素的 src 属性关联到一个 MediaSource 对象上去。调用revokeObjectURL() 使这个潜在的对象回到原来的地方，允许平台在合适的时机进行垃圾收集。 URL.revokeObjectURL() 12345/** * objectURL * 一个 DOMString，表示通过调用 URL.createObjectURL() 方法产生的 URL 对象**/URL.revokeObjectURL(objectURL); Blob APIBlob 对象表示一个不可变、原始数据的类文件对象。Blob 表示的不一定是JavaScript原生格式的数据。File 接口基于Blob，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。 要从其他非blob对象和数据构造一个 Blob，请使用 Blob() 构造函数。要创建一个 blob 数据的子集 blob，请使用 slice() 方法。要获取用户文件系统上的文件对应的 Blob 对象，请参阅 File 文档。 接受 Blob 对象的API也被列在 File 文档中。 Blob API Blob 构造函数1var aBlob = new Blob( array, options ); array 是一个由ArrayBuffer, ArrayBufferView, Blob, DOMString 等对象构成的 Array ，或者其他类似对象的混合体，它将会被放进 Blob。DOMStrings会被编码为UTF-8。 options 是一个可选的BlobPropertyBag字典，它可能会指定如下两个属性： type，默认值为 “”，它代表了将会被放入到blob中的数组内容的MIME类型。 endings，默认值为”transparent”，用于指定包含行结束符\n的字符串如何被写入。 它是以下两个值中的一个： “native”，代表行结束符会被更改为适合宿主操作系统文件系统的换行符，或者 “transparent”，代表会保持blob中保存的结束符不变 Blob 对象属性 size 只读Blob 对象中所包含数据的大小（字节）。 type 只读一个字符串，表明该 Blob 对象所包含数据的 MIME 类型。如果类型未知，则该值为空字符串。 Blob 方法 Blob.slice([start[, end[, contentType]]])返回一个新的 Blob 对象，包含了源 Blob 对象中指定范围内的数据。 Blob.stream()返回一个能读取blob内容的 ReadableStream。 Blob.text()返回一个promise且包含blob所有内容的UTF-8格式的 USVString。 Blob.arrayBuffer()返回一个promise且包含blob所有内容的二进制格式的 ArrayBuffer Blob实例 ArrayBufferArrayBuffer 对象用来表示通用的、固定长度的原始二进制数据缓冲区。 它是一个字节数组，通常在其他语言中称为“byte array”。 你不能直接操作 ArrayBuffer 的内容，而是要通过类型数组对象或 DataView 对象来操作，它们会将缓冲区中的数据表示为特定的格式，并通过这些格式来读写缓冲区的内容。 语法new ArrayBuffer(length) length要创建的 ArrayBuffer 的大小，单位为字节。 ArrayBuffer API TypeArray一个类型化数组（TypedArray）对象描述了一个底层的二进制数据缓冲区（binary data buffer）的一个类数组视图（view）。事实上，没有名为 TypedArray 的全局属性，也没有一个名为 TypedArray 的构造函数。相反，有许多不同的全局属性，它们的值是特定元素类型的类型化数组构造函数，如下所示。在下面的页面中，你会发现一些，与包含任何类型的元素的任意类型化数组一起使用的通用属性和方法。 12345678910111213141516171819// 下面代码是语法格式，不能直接运行，// TypedArray 关键字需要替换为底部列出的构造函数。new TypedArray(); // ES2017中新增new TypedArray(length); new TypedArray(typedArray); new TypedArray(object); new TypedArray(buffer [, byteOffset [, length]]); // TypedArray 指的是以下的其中之一： Int8Array(); Uint8Array(); Uint8ClampedArray();Int16Array(); Uint16Array();Int32Array(); Uint32Array(); Float32Array(); Float64Array(); TypedArray API DataView API 1234567891011121314151617181920// 使用标准数组语法来获取和设置属性值var int16 = new Int16Array(2);int16[0] = 42;console.log(int16[0]); // 42// 原型中添加的属性访问不到（此时索引值未超边界，20 &lt; 32）Int8Array.prototype[20] = &quot;foo&quot;;(new Int8Array(32))[20]; // 0// 即使索引值超出了边界也一样不能访问（20 &gt; 8）Int8Array.prototype[20] = &quot;foo&quot;;(new Int8Array(8))[20]; // undefined// 使用负数索引也不行Int8Array.prototype[-1] = &quot;foo&quot;;(new Int8Array(8))[-1]; // undefined// 但是可以使用命名属性的方式访问到Int8Array.prototype.foo = &quot;bar&quot;;(new Int8Array(32)).foo; // &quot;bar&quot; Fetch API ResponseFetch API Response WebRTCWebRTCMediaSourceMediaStreamWebRTC samples Canvas绘制播放器Canvas播放器]]></content>
      <categories>
        <category>js 基础</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VPN]]></title>
    <url>%2FBlog%2F2020%2F07%2F14%2Fvpn%2F</url>
    <content type="text"><![CDATA[VPN V2Ray是什么V2Ray 是一个网络转发程序，支持 TCP、mKCP、WebSocket 这3种底层传输协议，支持 HTTP、Socks、Shadowsocks、VMess 这4种内容传输协议（HTTP只支持传入），并且有完整的 TLS 实现，是一个非常强大的平台。 简介V2Ray官网：https://www.v2ray.com ProjectVProject V 是一个工具集合，它可以帮助你打造专属的基础通信网络。Project V 的核心工具称为 V2Ray，其主要负责网络协议和功能的实现，与其它 Project V 通信。V2Ray 可以单独运行，也可以和其它工具配合，以提供简便的操作流程。 特性： 多入口多出口: 一个 V2Ray 进程可并发支持多个入站和出站协议，每个协议可独立工作。 可定制化路由: 入站流量可按配置由不同的出口发出。轻松实现按区域或按域名分流，以达到最优的网络性能。 多协议支持: V2Ray 可同时开启多个协议支持，包括 Socks、HTTP、Shadowsocks、VMess 等。每个协议可单独设置传输载体，比如 TCP、mKCP、WebSocket 等。 隐蔽性: V2Ray 的节点可以伪装成正常的网站（HTTPS），将其流量与正常的网页流量混淆，以避开第三方干扰。 反向代理: 通用的反向代理支持，可实现内网穿透功能。 多平台支持: 原生支持所有常见平台，如 Windows、Mac OS、Linux，并已有第三方支持移动平台。 ShadowsocksShadowsocks 协议，包含入站和出站两部分，兼容大部分其它版本的实现。 与官方版本的兼容性： 支持 TCP 和 UDP 数据包转发，其中 UDP 可选择性关闭； 支持 OTA； 客户端可选开启或关闭； 服务器端可强制开启、关闭或自适应； 加密方式（其中 AEAD 加密方式在 V2Ray 3.0 中加入）： aes-256-cfb aes-128-cfb chacha20 chacha20-ietf aes-256-gcm aes-128-gcm chacha20-poly1305 或称 chacha20-ietf-poly1305 插件： 通过 Standalone 模式支持 obfs Shadowsocks 的配置分为两部分，InboundConfigurationObject和OutboundConfigurationObject，分别对应入站和出站协议配置中的settings项。 InboundConfigurationObject 12345678&#123; "email": "love@v2ray.com", // 邮件地址，可选，用于标识用户 "method": "aes-128-cfb", // 加密方式，可选如上所示 "password": "密码", // 必填，任意字符串。Shadowsocks 协议不限制密码长度，但短密码会更可能被破解，建议使用 16 字符或更长的密码。 "level": 0, // 用户等级，默认为0 "ota": true, // 是否强制 OTA，如果不指定此项，则自动判断。强制开启 OTA 后，V2Ray 会拒绝未启用 OTA 的连接。反之亦然。 "network": "tcp" // 可接收的网络连接类型，默认值为"tcp"。 可选值："tcp" | "udp" | "tcp,udp"&#125; OutboundConfigurationObject 12345678910111213&#123; "servers": [ // 一个数组，其中每一项是一个 ServerObject。 &#123; "email": "love@v2ray.com", // 邮件地址，可选，用于标识用户 "address": "127.0.0.1", // Shadowsocks 服务器地址，支持 IPv4、IPv6 和域名。必填。 "port": 1234, // Shadowsocks 服务器端口。必填。 "method": "加密方式", // 必填。可选的值见加密方式列表 "password": "密码", // 必填。任意字符串。Shadowsocks 协议不限制密码长度，但短密码会更可能被破解，建议使用 16 字符或更长的密码。 "ota": false, // 是否开启 Shadowsocks 的一次验证（One time auth），默认值为false。 "level": 0 // 用户等级 &#125; ]&#125; VMessVMess 是一个加密传输协议，它分为入站和出站两部分，通常作为 V2Ray 客户端和服务器之间的桥梁。 VMess 依赖于系统时间，请确保使用 V2Ray 的系统 UTC 时间误差在 90 秒之内，时区无关。在 Linux 系统中可以安装ntp服务来自动同步系统时间。 VMess 的配置分为两部分，InboundConfigurationObject和OutboundConfigurationObject，分别对应入站和出站协议配置中的settings项。 InboundConfigurationObject 123456789101112131415161718&#123; "clients": [ &#123; "id": "27848739-7e62-4138-9fd3-098a63964b6b", "level": 0, "alterId": 4, "email": "love@v2ray.com" &#125; ], "default": &#123; "level": 0, "alterId": 4 &#125;, "detour": &#123; "to": "tag_to_detour" &#125;, "disableInsecureEncryption": false&#125; 其中： clients: 一组服务器认可的用户。clients 可以为空。当此配置用作动态端口时，V2Ray 会自动创建用户。 id: VMess 的用户 ID。必须是一个合法的 UUID。 level: 用户等级，详情见V2ray本地策略 alterId: 为了进一步防止被探测，一个用户可以在主 ID 的基础上，再额外生成多个 ID。这里只需要指定额外的 ID 的数量，推荐值为 4。不指定的话，默认值是 0。最大值 65535。这个值不能超过服务器端所指定的值。 email: 用户邮箱地址，用于区分不同用户的流量。 detour: 指示对应的出站协议使用另一个服务器。 to: 一个入站协议的tag，详见V2ray配置文件。指定的入站协议必须是一个 VMess default: 可选，clients 的默认配置。仅在配合detour时有效。 disableInsecureEncryption: 是否禁止客户端使用不安全的加密方式，当客户端指定下列加密方式时，服务器会主动断开连接。默认值为false。 “none” “aes-128-cfb” OutboundConfigurationObject 12345678910111213141516&#123; "vnext": [ &#123; "address": "127.0.0.1", "port": 37192, "users": [ &#123; "id": "27848739-7e62-4138-9fd3-098a63964b6b", "alterId": 4, "security": "auto", "level": 0 &#125; ] &#125; ]&#125; 其中： vnext表示服务器配置 address: 地址 port: 端口 users: 用户信息 id: VMess 用户的主 ID。必须是一个合法的 UUID。 alterId: 为了进一步防止被探测，一个用户可以在主 ID 的基础上，再额外生成多个 ID。这里只需要指定额外的 ID 的数量，推荐值为 4。不指定的话，默认值是 0。最大值 65535。这个值不能超过服务器端所指定的值。 level: 用户等级 security: 加密方式，客户端将使用配置的加密方式发送数据，服务器端自动识别，无需配置。 “aes-128-gcm”：推荐在 PC 上使用 “chacha20-poly1305”：推荐在手机端使用 “auto”：默认值，自动选择（运行框架为 AMD64、ARM64 或 s390x 时为aes-128-gcm加密方式，其他情况则为 Chacha20-Poly1305 加密方式） “none”：不加密 推荐使用&quot;auto&quot;加密方式，这样可以永久保证安全性和兼容性。 安装流程1.购买VPS任何境外 VPS 都可以，一般而言香港、台湾、新加坡、韩国、日本等亚洲机房速度（延迟小）最快，但价格较贵，并且由于用的人多经常会被重点关照。无论如何，如果预算充足并追求速度可以选择这些机房，但需要提前了解测试线路是否是直连中国，一些线路可能会绕美国。 美国VPS价格低廉宽带足，其中的洛杉矶(Los Angeles)、西雅图(Seattle)两个机房对中国物理距离最近，这两个机房为首选。 推荐VirMach,便宜的1.25刀一个月，一次性买10个月，送两个月 123456256MB DEDICATED RAM1 vCORE10GB SSD (HW RAID 10)DDoS Protection Available500GB BANDWIDTH1GBPS 服务器可以配置为Ubuntu或者CenterOS,看个人喜好 使用终端ssh登录 2.安装V2RayV2Ray 提供了一个在 Linux 中的自动化安装脚本。这个脚本会自动检测有没有安装过 V2Ray，如果没有，则进行完整的安装和配置；如果之前安装过 V2Ray，则只更新 V2Ray 二进制程序而不更新配置。 以下指令假设已在 su 环境下，如果不是，请先运行 sudo su。 运行下面的指令下载并安装 V2Ray。当 yum 或 apt-get 可用的情况下，此脚本会自动安装 unzip 和 daemon。这两个组件是安装 V2Ray 的必要组件。如果你使用的系统不支持 yum 或 apt-get，请自行安装 unzip 和 daemon 可能需要安装curl，unzip，git等工具 12sudo -ibash &lt;(curl -s -L https://git.io/v2ray.sh) 然后选择安装，即是输入 1 回车; 选择传输协议，如果没有特别的需求，使用默认的 TCP 传输协议即可，直接回车; 选择端口，如果没有特别的需求，使用默认的端口即可，直接回车; 是否屏蔽广告，除非你真的需要，一般来说，直接回车即可; 是否配置 Shadowsocks ，如果不需要就直接回车，否则就输入 Y 回车; Shadowsocks 端口，密码，加密方式这些东西自己看情况配置即可，一般全部直接回车。OK，按回车继续; 最后安装完成后会提示安装信息，建议记录下。 此脚本会自动安装以下文件： /usr/bin/v2ray/v2ray：V2Ray 程序； /usr/bin/v2ray/v2ctl：V2Ray 工具； /etc/v2ray/config.json：配置文件； /usr/bin/v2ray/geoip.dat：IP 数据文件 /usr/bin/v2ray/geosite.dat：域名数据文件 此脚本会配置自动运行脚本。自动运行脚本会在系统重启之后，自动运行 V2Ray。目前自动运行脚本只支持带有 Systemd 的系统，以及 Debian / Ubuntu 全系列。 运行脚本位于系统的以下位置： /etc/systemd/system/v2ray.service: Systemd /etc/init.d/v2ray: SysV 脚本运行完成后，你需要： 编辑 /etc/v2ray/config.json 文件来配置你需要的代理方式； config.json配置如下所示： 12345678910111213&#123; "inbounds": [&#123; "port": 10086, // 服务器监听端口，必须和上面的一样 "protocol": "vmess", "settings": &#123; "clients": [&#123; "id": "b831381d-6324-4d53-ad4f-8cda48b30811" &#125;] &#125; &#125;], "outbounds": [&#123; "protocol": "freedom", "settings": &#123;&#125; &#125;]&#125; 运行 service v2ray start 来启动 V2Ray 进程；之后可以使用 service v2ray start|stop|status|reload|restart|force-reload 控制 V2Ray 的运行。 客户端配置信息(PC,iphone)： 1234567891011121314151617181920212223242526272829303132&#123; "inbounds": [&#123; "port": 1080, // SOCKS 代理端口，在浏览器中需配置代理并指向这个端口 "listen": "127.0.0.1", "protocol": "socks", "settings": &#123; "udp": true &#125; &#125;], "outbounds": [&#123; "protocol": "vmess", "settings": &#123; "vnext": [&#123; "address": "server", // 服务器地址，请修改为你自己的服务器 ip 或域名 "port": 10086, // 服务器端口 "users": [&#123; "id": "b831381d-6324-4d53-ad4f-8cda48b30811" &#125;] &#125;] &#125; &#125;,&#123; "protocol": "freedom", "tag": "direct", "settings": &#123;&#125; &#125;], "routing": &#123; "domainStrategy": "IPOnDemand", "rules": [&#123; "type": "field", "ip": ["geoip:private"], "outboundTag": "direct" &#125;] &#125;&#125; 开放响应端口：CenterOS7开放响应端口 V2Ray常用命令 v2ray info：查看 V2Ray 配置信息 v2ray config：修改 V2Ray 配置 v2ray link：生成 V2Ray 配置文件链接 v2ray infolink：生成 V2Ray 配置信息链接 v2ray qr：生成 V2Ray 配置二维码链接 v2ray ss：修改 Shadowsocks 配置 v2ray ssinfo：查看 Shadowsocks 配置信息 v2ray ssqr：生成 Shadowsocks 配置二维码链接 v2ray status：查看 V2Ray 运行状态 v2ray start：启动 V2Ray v2ray stop：停止 V2Ray v2ray restart:重启 V2Ray v2ray log：查看 V2Ray 运行日志 v2ray update：更新 V2Ray v2ray update.sh：更新 V2Ray 管理脚本 v2ray uninstall：卸载 V2Ray 神一样的工具V2RayW V2RayW 是一个基于 V2Ray 内核的 Windows 客户端。用户可以通过界面生成配置文件，并且可以手动更新 V2Ray 内核。下载：GitHub V2RayN V2RayN 是一个基于 V2Ray 内核的 Windows 客户端。下载：GitHub Clash for Windows 下载：GitHub V2RayX V2RayX 是一个基于 V2Ray 内核的 Mac OS X 客户端。用户可以通过界面生成配置文件，并且可以手动更新 V2Ray 内核。V2RayX 还可以配置系统代理。下载：Github V2RayU V2rayU,基于v2ray核心的mac版客户端,界面友好,使用swift4.2编写,支持vmess,shadowsocks,socks5等服务协议,支持订阅, 支持二维码,剪贴板导入,手动配置,二维码分享等。下载：GitHub V2RayC 下载：GitHub ClashX 下载：GitHub Qv2ray Qv2ray：使用 Qt 编写的 v2ray 跨平台 GUI （MacOS, Windows, Linux）支持连接导入和编辑，中英文切换 下载：GitHub 官网：https://lhy0403.github.io/Qv2ray Mellow Mellow 是一个基于规则的全局透明代理工具，可以运行在 Windows、macOS 和 Linux 上，也可以配置成路由器透明代理或代理网关，支持 SOCKS、HTTP、Shadowsocks、VMess 等多种代理协议。 Download: Github Kitsunebi Kitsunebi 是一个基于 V2Ray 核心的移动平台应用 (iOS, Android)。它可以创建基于 VMess 或者 Shadowsocks 的 VPN 连接。Kitsunebi 支持导入和导出与 V2Ray 兼容的 JSON 配置。 由于使用 V2Ray 核心，Kitsunebi 几乎支持 V2Ray 的所有功能，比如 Mux 和 mKCP。 下载：iTunes | Play Store i2Ray i2Ray 是另一款基于 V2Ray 核心的iOS应用。界面简洁易用，适合新手用户使用。同时兼容Shadowrocket和Quantumult格式的规则导入。 下载：iTunes Shadowrocket Shadowrocket 是一个通用的 iOS VPN 应用，它支持众多协议，如 Shadowsocks、VMess、SSR 等。 下载：iTunes Pepi（原名ShadowRay） Pepi 是一个兼容 V2Ray 的 iOS 应用，它可以创建基于 VMess 的 VPN 连接，并与 V2Ray 服务器通信。 下载：iTunes Quantumult 下载：iTunes BifrostV BifrostV 是一个基于 V2Ray 内核的 Android 应用，它支持 VMess、Shadowsocks、Socks 协议。 下载：Play Store V2RayNG V2RayNG 是一个基于 V2Ray 内核的 Android 应用，它可以创建基于 VMess 的 VPN 连接。 下载：GitHub 在线工具/资源 VeekXT V2Ray配置生成 支持 4.x 版本的配置文件生成器 veekxt.com V2Ray 配置生成器 静态 V2Ray 配置文件生成页面 GitHub UUID Generator VMess User ID 生成工具 uuidgenerator.net vTemplate 项目仓库 一个 V2Ray 配置文件模板收集仓库 GitHub 3.Cloudflare中转V2Ray Websocket流量首先需要一个域名，可以通过freenom来获取免费使用一年的域名。 注册Cloudflare，添加DNS记录， 然后在freenom上面配置Nameservers 可参考教程：使用Cloudflare+WebSocket+TLS+Nginx搭建V2ray拯救被封国外VPS 脚本已可用 V2Ray 基于 Nginx 的 vmess+ws+tls 一键安装脚本 国内外网站分享 翻墙必去 www.google.com,这个就不多说了 Instagram，Twitter 程序员网站： 国外： https://stackoverflow.com/ 国内： 掘金，思否 刷题网站 力扣, CodeWars AirPano-不出门看遍全球风景 图片压缩 TinyJPG,TinyPNG HTML颜色 html-color-codes 字体图标库 http://fontello.com/, ICONSVG ICONSVG 支持导出SVG,jsx和React代码，可直接使用 123import React from "react";const MapMarker3 = (&#123;size=24, color="#000000"&#125;) =&gt; (&lt;svg xmlns="http://www.w3.org/2000/svg" width=&#123;size&#125; height=&#123;size&#125; viewBox="0 0 24 24" fill="none" stroke=&#123;color&#125; strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"&gt;&lt;circle cx="11.5" cy="8.5" r="5.5"/&gt;&lt;path d="M11.5 14v7"/&gt;&lt;/svg&gt;);export default MapMarker3; 参考文章： V2Ray完全使用教程, V2Ray 搭建教程以及一键安装脚本,]]></content>
      <categories>
        <category>VPN V2Ray</category>
      </categories>
      <tags>
        <tag>VPN, V2Ray</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typescript]]></title>
    <url>%2FBlog%2F2020%2F05%2F27%2Ftypescript%2F</url>
    <content type="text"><![CDATA[typescript详解 首先要安装typescript 基本数据类型：一、布尔类型：boolean true false1let isDone: boolean = false; 二、数字 :number1let num: number = 6; 三、字符串 :string1let str: string = &quot;bob&quot;; 四、数组类型:在 TypeScript 中，数组类型有多种定义方式，比较灵活。1、「类型 + 方括号」表示法1let fibonacci: number[] = [1, 1, 2, 3, 5]; 2、数组泛型我们也可以使用数组泛型（Array Generic）Array来表示数组1let fibonacci: Array&lt;number&gt; = [1, 1, 2, 3, 5]; 3、用接口表示数组1234interface NumberArray &#123; [index: number]: number;&#125;let fibonacci: NumberArray = [1, 1, 2, 3, 5] 数组：建议使用前两个方法，比较简单 arguments 实际上是一个类数组，不能用普通的数组的方式来描述，而应该用接口：1234567function sum() &#123; let args: &#123; [index: number]: number; length: number; callee: Function; &#125; = arguments;&#125; 五、元组类型Tuple：属于数组的一种，可以指定值（单个值）的类型1let arr:[string,number,boolean]=[‘1’,1,false]; 六、枚举类型 enum随着计算机的不断普及，程序不仅仅只用于数值计算，还更广泛地用于处理非数值数据事先考虑某一个变量可能取的值，尽量用自然语言中含义清楚的单词来表示每一个值，这种方法称为枚举方法，把这种方法定义的类型称为枚举类型enum类型是对JavaScript标准数据类型的一个补充默认没有赋值的话，会打印索引值123456789101112enum RequestMethod&#123; Get, Post, Put, Delete, Options, Head, Patch&#125;let requestMethod = RequestMethod.Get;console.log(requestMethod); // 0 上面定义的 RequestMethod 枚举会被编译成以下 ES5 代码：12345678910111213&quot;use strict&quot;;var RequestMethod;(function(RequestMethod)&#123; RequestMethod[RequestMethod[&quot;Get&quot;] = 0] = &quot;Get&quot;; RequestMethod[RequestMethod[&quot;Post&quot;] = 1] = &quot;Post&quot;; RequestMethod[RequestMethod[&quot;Put&quot;] = 2] = &quot;Put&quot;; RequestMethod[RequestMethod[&quot;Delete&quot;] =3] = &quot;Delete&quot;; RequestMethod[RequestMethod[&quot;Options&quot;] = 4] = &quot;Options&quot;; RequestMethod[RequestMethod[&quot;Head&quot;] = 5] = &quot;Head&quot;; RequestMethod[RequestMethod[&quot;Patch&quot;] = 6] = &quot;Patch&quot;;&#125;)(RequestMethod || (RequestMethod = &#123;&#125;));var requestMethod = RequestMethod.Get;console.log(requestMethod); 设置中间枚举成员的值123456789enum RequestMethod &#123; Get, Post, Put, Delete = 8, Options, Head, Patch&#125; 以上代码编译生成的 ES5 代码如下：1234567891011&quot;use strict&quot;;var RequestMethod;(function(RequestMethod)&#123; RequestMethod[RequestMethod[&quot;Get&quot;] = 0] = &quot;Get&quot;; RequestMethod[RequestMethod[&quot;Post&quot;] = 1] = &quot;Post&quot;; RequestMethod[RequestMethod[&quot;Put&quot;] = 2] = &quot;Put&quot;; RequestMethod[RequestMethod[&quot;Delete&quot;] = 8] = &quot;Delete&quot;; RequestMethod[RequestMethod[&quot;Options&quot;] = 9] = &quot;Options&quot;; RequestMethod[RequestMethod[&quot;Head&quot;] = 10] = &quot;Head&quot;; RequestMethod[RequestMethod[&quot;Patch&quot;] = 11] = &quot;Patch&quot;;&#125;)(RequestMethod || (RequestMethod = &#123;&#125;)); 七、任意类型any (anyscript)八、null和undefined 使用联合类型null和undefined可以被赋值给Typescript中的所有类型12345let s:string | null | undefined = undefined;let foo:number = 123;foo = null; // okfoo = undefined; // ok 九、void类型Typescript中的void表示没有任何类型，一般定义方法的时候方法没有返回值使用：void来表示一个函数没有一个返回值1function log(message:string):void&#123;&#125; 十、never类型never类型表示的是那些永不存在的值的类型。例如，never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是never类型，当它们被永不为真的类型保护所约束时。12345678910111213141516// 返回never的函数必须存在无法达到的终点function error(message: string): never &#123; throw new Error(message);&#125;// 推断的返回值类型为neverfunction fail() &#123; return error(&quot;Something failed&quot;);&#125;// 返回never的函数必须存在无法达到的终点function infiniteLoop(): never &#123; while (true) &#123; &#125;&#125; 其他类型值包含null和undefined的子类型，代表不会出现的值。这意味着never的变量只能被never类型所赋值类型断言通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。类型断言有两种形式。其一是“尖括号”语法：12let someValue:any = &quot;this is a string&quot;;let strLength:number = (&lt;string&gt;someValue).length; 另一个为as语法：12let someValue: any = &quot;this is a string&quot;;let strLength: number = (someValue as string).length; 十一、Objectobject表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。使用object类型，就可以更好的表示像Object.create这样的API。例如：1declare function create(o: object | null): void; 函数123456789// Named functionfunction add(x, y) &#123; return x + y;&#125;// Anonymous functionlet myAdd = function(x, y) &#123; return x + y; &#125;; 让我们为上面那个函数添加类型：1234567function add(x: number, y: number): number &#123; return x + y;&#125;let myAdd = function(x: number, y: number): number &#123; return x + y; &#125;; 可选参数和默认参数12345678910function buildName(firstName: string, lastName?: string) &#123; if (lastName) return firstName + &quot; &quot; + lastName; else return firstName;&#125;let result1 = buildName(&quot;Bob&quot;); // works correctly nowlet result2 = buildName(&quot;Bob&quot;, &quot;Adams&quot;, &quot;Sr.&quot;); // error, too many parameterslet result3 = buildName(&quot;Bob&quot;, &quot;Adams&quot;); // ah, just right 剩余参数12345function buildName(firstName: string, ...restOfName: string[]) &#123; return firstName + &quot; &quot; + restOfName.join(&quot; &quot;);&#125;let employeeName = buildName(&quot;Joseph&quot;, &quot;Samuel&quot;, &quot;Lucas&quot;, &quot;MacKinzie&quot;); ts函数的重载Java中方法的重载：重载指的是两个或两个以上同名的函数，但他们参数不一样，这样就会有函数重载的情况Typescript中的重载，通过为同个函数与提供多个函数类型定义来实现多种功能的目的12345678910111213141516171819// 重载function padding(all: number);function padding(topAndBottom: number, leftAndRight: number);function padding(top: number, right: number, bottom: number, left: number);// 函数体需要处理的所有情况的真实表示function padding(a: number, b?: number, c?: number, d?: number) &#123; if (b === undefined &amp;&amp; c === undefined &amp;&amp; d === undefined) &#123; b = c = d = a; &#125; else if (c === undefined &amp;&amp; d === undefined) &#123; c = a; d = b; &#125; return &#123; top: a, right: b, bottom: c, left: d &#125;;&#125; 这里前三个函数头可有效调用 padding:12345padding(1); // Okay: allpadding(1, 1); // Okay: topAndBottom, leftAndRightpadding(1, 1, 1, 1); // Okay: top, right, bottom, leftpadding(1, 1, 1); // Error: Not a part of the available overloads 函数参数解构的写法：1234567function f(&#123; x: number &#125;) &#123; // Error, x is not defined? console.log(x);&#125;function f(&#123;x&#125;:&#123;x:number&#125;) &#123; console.log(x)&#125; 泛型：使用any类型会导致这个函数可以接收任何类型的arg参数，这样就丢失了一些信息：传入的类型与返回的类型应该是相同的。如果我们传入一个数字，我们只知道任何类型的值都有可能被返回。因此，我们需要一种方法使返回值的类型与传入参数的类型是相同的。这里，我们使用了类型变量，它是一种特殊的变量，只用于表示类型而不是值你可能会疑惑为什么类型参数是S, 其实随便什么都可以，但是通常来说我们会用一个变量的第一个字母的大写来代表这个变量的类型：1234T(for“T”ype)E(for“E”lement)K(for“K”ey)V(for“V”alue) 1234567891011function identity(arg: number): number &#123; return arg;&#125;function identity(arg: string): string &#123; return arg;&#125;function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125; 使用泛型后，可以接受任意类型，但是又完成了函数参数和返回值的约束关系。十分灵活~可复用性大大增强了我们给indentity添加了类型变量T。T帮助我们捕获用户传入的类型（比如：number），之后我们就可以使用这个类型。之后我们再次使用了T当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。这允许我们跟踪函数里使用的类型的信息。我们把这个版本的identity函数叫做泛型，因为它可以适用于多个类型。不同于使用any，它不回丢失信息，想第一个例子那像保持准确性，传入所有的参数，包含类型参数1let output = identity&lt;string&gt;(“myString”); 这里我们明确的指定了T是string类型，并做为一个参数传给函数，使用了&lt;&gt;括起来而不是（）第二种方法更普遍。利用了类型推论—即编译器会根据传入的参数自动地帮助我们确定T的类型1let output = indetity(“myString”); 注意我们没必要使用尖括号（&lt;&gt;）来明确地传入类型；编译器可以查看myString的值，然后把T设置为它的类型。类型推论帮助我们保持代码精简和高可读性。如果编译器不能够自动地推断出类型的话，只能像上面一样明确传入T的类型，在一些复杂的情况下，这是可能出现的泛型类型indentity通用函数，可以适用于不同的类型。我们研究一下函数本身的类型，以及如何创建泛型接口泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面，像函数声明一样：forEach &amp; map12forEach(callbackfn: (value: T, index: number, array: T[]) =&gt; void, thisArg?: any): void;map&lt;U&gt;(callbackfn: (value: T, index: number, array: T[]) =&gt; U, thisArg?: any): U[]; forEach 一般用来执行副作用的，比如持久的修改一下元素、数组、状态等，以及打印日志等，本质上是不纯的。而 map 方法用来作为值的映射，本质上是纯净的，在函数式编程里十分重要。 接口（interfaces）接口的作用：在面向对象的编程中，接口是一种规范的定义。定义了行为和动作的规范。在程序设计中，接口起到了一种限制和规范的作用。接口定义了某一批所需要遵守的规范。我们定义了一个接口Person，接着定义了一个变量tom。它的类型是Person。这样，我们就约束了tom的形状和接口Person一致。Typescript中的接口分类1、 属性类接口 属性接口 对json的约束2、 函数类型接口3、 可索引接口4、 类类型接口5、 接口扩展ts中定义方法传入参数对json的约束行为和动作的规范，对批量方法进行约束一、接口可选属性（参数的顺序无所谓）12345678910111213141516interface Config&#123; type:string; url:sting; data?:string; datatype:string;&#125;function ajax(config:Config)&#123; car xhr= new XMLHttpRequest(); xhr.open(config.type,config.url,true); xhr.send(config.data); xhr.readystatechange=function()&#123; if(xhr.readyState===4 &amp;&amp; xhr.status==200)&#123; &#125; &#125;&#125; 二、函数类型接口可以使用接口的方式来定义一个函数需要符合的形状1234567interface encrypt &#123; (key:string,value:string) : string&#125;let md5:encrypt = (key:string,value:string):string &#123; return key+value&#125; encrypt这个接口规定了函数的传参为key和value两个变量，并且这两个变量都是string类型。同时规定了函数的返回值也是string类型。12345678interface Person &#123; name:sting; age:number;&#125;let tom:Person=&#123; name:’tom’, age:25&#125; 三、可索引接口（1）对数组的约束12345interface UserArr&#123; [index:number] : string&#125;let arr:UserArr = [&apos;aaa&apos;,&apos;bbb&apos;]console.log(arr[0]) // aaa (2)对对象的约束123let foo = &#123;&#125;;foo.bar = 123; // error: 类型 &#123;&#125; 上不存在属性barfoo.bas = &apos;Hello World&apos;; // error: 类型 &#123;&#125; 上不存在属性bas 1234567interface UserObj&#123; [key:string]: string | number&#125;const obj:UserObj = &#123; name: &apos;Leon&apos;, age: 18&#125; 四、类类型接口implements实现（implements）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用 implements 关键字来实现。这个特性大大提高了面向对象的灵活性12345678910111213141516interface Animal&#123; name: string eat(str:string):void&#125;//可以用implements来实现这个类class Dog implememts Animal &#123; name: string //ES6 中实例的属性只能通过构造函数中的 this.xxx 来定义，ES7 提案中可以直接在类里面定义： constructor(name:string) &#123; this.name = name &#125; eat() &#123; console.log(this.name+&apos;吃骨头&apos;) &#125;&#125;let d = new Dog(&apos;小黑&apos;)d.eat()//小黑吃骨头 一个类可以实现多个接口：12345678910111213141516interface Shape &#123; color: string;&#125;interface PenStroke &#123; penWidth: number;&#125;interface Square extends Shape, PenStroke &#123; sideLength: number;&#125;let square = &lt;Square&gt;&#123;&#125;;square.color = &quot;blue&quot;;square.sideLength = 10;square.penWidth = 5.0; 五、实现接口的扩展接口和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。12345interface ErrorMsg extends Error &#123; name: any; response?: any;&#125;const error: ErrorMsg = new Error(errortext); 类（Classes）ts表示类123456789101112131415161718class Person&#123; name:string; // 属性前面省略，代表public constructor(name:string) &#123; // 构造函数，实例化类的时候触发 this.name=name &#125; run():void&#123; &#125;&#125;``` 类里面的修饰符 typescript中提供三种修饰符 public 公有，在类里面、子类、类外面都可以访问 protected 保护类型，在类里面，子类里面可以访问，在类外部都没法访问 private 私有 在类里面可以访问、子类，类外部都没法访问 默认不加修饰符就是public 1、理解private 当成员被标记成private时，它就不能在声明它的类的外部访问。比如： class Animal { private name: string; constructor(theName: string) { this.name = theName; }}new Animal(“Cat”).name; // 错误: ‘name’ 是私有的.122、理解protected protected修饰符与private修饰符的行为很相似，但有一点不同，protected成员在子类中仍然可以访问。例如： class Person { protected name: string; constructor(name: string) { this.name = name; }} class Employee extends Person { private department: string; constructor(name: string, department: string) { super(name) this.department = department; } public getElevatorPitch() { return `Hello, my name is ${this.name} and I work in ${this.department}.`; } } let howard = new Employee(“Howard”, “Sales”);console.log(howard.getElevatorPitch());console.log(howard.name); // 错误123、readonly修饰符 使用readonly关键字将属性设置为只读的。 class Octopus { readonly name: string; readonly numberOfLegs: number = 8; constructor (theName: string) { this.name = theName; }}let dad = new Octopus(“Man with the 8 strong legs”);dad.name = “Man with the 3-piece suit”; // 错误! name 是只读的.123typescript中实现继承 (省略) 静态属性、静态方法 es5的静态方法的表示： function Person{ this.run=function(){ } }Person.sex=’男’; // 静态属性Person.print=function(){ // 静态方法 }12静态方法： class Person{ public name:string static sex:’男’ constructor(name:string){ this.name=name } run(){ // 实例方法 alert(this.name) } static print(){ console.log(this.name) // 报错 静态方法中没有办法直接调用类中的属性，只能调用静态属性,this.sex可用 }}1实例方法的调用： var p = new Person(‘张三’)p.run();1静态方法的调用 Person.print()123456多态属于继承 多态：父类定义一个方法不去实现，让继承它的子类去实现，每个子类有不同的表现 抽象方法、抽象类 abstract用来表示抽象 抽象方法只能放在抽象类中 ,抽象类和抽象方法用来定义标准 abstract class Animal{ abstract eat():any}1typescript的抽象类，它是提供其他继承的基类，不能直接被实例化。abstract类无法创建实例 var a =new Animal(); // 报错`用abstract关键字定义的抽象类和抽象方法。抽象类中的抽象方法不包含其实现并且必须在派生类中实现。抽象类的抽象方法在子类就必须要实现。不实现就会报错 学习成本：需要理解接口（interfaces）、泛型（Generics）、类（Classes）、枚举类型（Enums）]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次前端国际化]]></title>
    <url>%2FBlog%2F2020%2F04%2F01%2Fintl%2F</url>
    <content type="text"><![CDATA[React项目国际化背景问题及带来思考 1.语言翻译 项目前期建立时,仅考虑支持中文,未考虑支持多语言版本(前期决策很关键,对一个旧工程做国际化改造是十分痛苦的) 翻译方式: 手动翻译(准确性高,但是耗时)、 借助开放平台跑自动化脚本(准确性和语义会打一定折扣,效率高) 2.map表维护 一个文件维护(文件太大, 可能会对页面加载速率带来一定影响, 但是对于自动化脚本翻译方便) 多个文件维护(拆发了词表, 并根据页面动态加载词表, 对页面加载友好, 但是可能会增大维护成本, 自动化脚本处理也会带来一定问题) 3.样式问题 不同语言的文本长度不一样会造成样式错乱(这里暂时未处理) 解决方案集成react-intlreact-intl详细代码 例子: 1234567891011121314151617181920212223242526272829303132import React from &apos;react&apos;import ReactDOM from &apos;react-dom&apos;import &#123;injectIntl, IntlProvider, FormattedRelative&#125; from &apos;react-intl&apos;const PostDate = injectIntl((&#123;date, intl&#125;) =&gt; ( &lt;span title=&#123;intl.formatDate(date)&#125;&gt; &lt;FormattedRelative value=&#123;date&#125; /&gt; &lt;/span&gt;))const App = (&#123;post&#125;) =&gt; ( &lt;div&gt; &lt;h1&gt;&#123;post.title&#125;&lt;/h1&gt; &lt;p&gt; &lt;PostDate date=&#123;post.date&#125; /&gt; &lt;/p&gt; &lt;div&gt;&#123;post.body&#125;&lt;/div&gt; &lt;/div&gt;)ReactDOM.render( &lt;IntlProvider locale=&#123;navigator.language&#125;&gt; &lt;App post=&#123;&#123; title: &apos;Hello, World!&apos;, date: new Date(1459913574887), body: &apos;Amazing content.&apos;, &#125;&#125; /&gt; &lt;/IntlProvider&gt;, document.getElementById(&apos;container&apos;)) react-intl本身不支持动态加载, 我们需要自己实现 基于react-intl的动态加载高阶组件实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import React, &#123; PureComponent, Fragment &#125; from &apos;react&apos;;import &#123; connect &#125; from &apos;dva&apos;;import &#123; IntlProvider, injectIntl &#125; from &apos;react-intl&apos;;const IntlMap = &#123; zh_CN: &apos;zh&apos;, en_US: &apos;en&apos;, th_TH: &apos;th&apos;,&#125;;@connect((&#123; global &#125;) =&gt; (&#123; global &#125;))export class DynamicWrapperIntl extends PureComponent &#123; state = &#123; data: null, &#125;; componentDidMount() &#123; this.resolveImport(); &#125; componentDidUpdate(prevProps) &#123; if (prevProps.global.langs !== this.props.global.langs) &#123; this.resolveImport(); &#125; &#125; resolveImport = () =&gt; &#123; const &#123; global: &#123; langs = &apos;zh_CN&apos; &#125;, name &#125; = this.props; if (typeof name === &apos;string&apos;) &#123; import(`../../locale/$&#123;langs&#125;/$&#123;name&#125;`) .then(m =&gt; &#123; // console.log(&apos;DynamicWrapperIntl:&apos;, m.default); this.setState(&#123; data: m.default, &#125;); &#125;) .catch(e =&gt; &#123; console.log(&apos;DynamicWrapperIntl:&apos;, e); &#125;); &#125; else if (name instanceof Array) &#123; Promise.all(name.map(i =&gt; import(`../../locale/$&#123;langs&#125;/$&#123;i&#125;`))) .then(m =&gt; &#123; const data = m.reduce((acc, cur) =&gt; &#123; acc = &#123; ...acc, ...cur.default, &#125;; return acc; &#125;, &#123;&#125;); this.setState(&#123; data, &#125;); &#125;) .catch(e =&gt; &#123; console.log(&apos;DynamicWrapperIntl:&apos;, e); &#125;); &#125; &#125;; render() &#123; const &#123; global: &#123; langs = &apos;zh_CN&apos; &#125; &#125; = this.props; const &#123; data &#125; = this.state; return ( &lt;Fragment&gt; &#123;data &amp;&amp; ( &lt;IntlProvider locale=&#123;IntlMap[langs]&#125; messages=&#123;data&#125;&gt; &#123;this.props.children(&#123; langs, locales: data, &#125;)&#125; &lt;/IntlProvider&gt; )&#125; &lt;/Fragment&gt; ); &#125;&#125;export const withDynamicWrapperIntl = (name, setting = &#123;&#125;) =&gt; WrapperComponent =&gt; &#123; const Wrapper = withInjectIntl(setting)(WrapperComponent); return class DynamicWrapperIntlHoc extends PureComponent &#123; render() &#123; return ( &lt;DynamicWrapperIntl name=&#123;name&#125;&gt; &#123;wrapperProps =&gt; &lt;Wrapper &#123;...this.props&#125; &#123;...wrapperProps&#125; /&gt;&#125; &lt;/DynamicWrapperIntl&gt; ); &#125; &#125;;&#125;;export const withInjectIntl = (setting = &#123;&#125;) =&gt; WrapperComponent =&gt; injectIntl(WrapperComponent, setting); 基于开放API的nodejs自动化翻译工具实现1.基于开放api接口的可配置性实现2.错误记录文件,结果记录文件,日志3.可扩展性,目前基于百度API实现,通过同一套配置如何集成更多开放翻译API]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何创建并发布自己的npm包]]></title>
    <url>%2FBlog%2F2020%2F03%2F14%2FnpmPublish%2F</url>
    <content type="text"><![CDATA[常用npm命令npm version 语法123456npm version [&lt;newversion&gt; | major | minor | patch | premajor | preminor | prepatch | prerelease [--preid=&lt;prerelease-id&gt;] | from-git]&apos;npm [-v | --version]&apos; to print npm version&apos;npm view &lt;pkg&gt; version&apos; to view a package&apos;s published version&apos;npm ls&apos; to inspect current package/dependency versionsDESCRIPTION§ 在命令行窗口输入npm version ?可以查看可以使用的命令:1234567major: 主版本号premajor: 预备主版本minor: 次版本号preminor: 预备次版本patch: 修订号prepatch: 预备修订版prerelease: 预发布版本 执行命令及版本提升示例：123456789101112131415假设初始版本为0.0.0➜ xxx git:(master) npm version preminorv0.1.0-0➜ xxx git:(master) npm version minorv0.1.0➜ xxx git:(master) npm version prepatchv0.1.1-0➜ xxx git:(master) npm version patch v0.1.1➜ xxx git:(master) npm version prereleasev0.1.2-0➜ xxx git:(master) npm version premajorv1.0.0-0➜ xxx git:(master) npm version major v1.0.0 npm publish123npm publish [&lt;tarball&gt;|&lt;folder&gt;][--tag &lt;tag&gt;] [--access &lt;public|restricted&gt;][--otp otpcode] [--dry-run]Publishes &apos;.&apos; if no argument suppliedSets tag &apos;latest&apos; if no --tag specified &lt;folder&gt;：包含 package.json 文件的文件夹 &lt;tarball&gt;：压缩后的 tar 存档的 url 或文件路径，其中包含单个文件夹，其中包含 package.json 文件。 [–tag &lt;tag&gt;] 使用给定标签注册发布的软件包，例如npm install @将安装此版本。默认情况下，npm publish更新和npm install安装latest标签。有关标签的详细信息，请参见npm-dist-tag。 [–access &lt;public|restricted&gt;] 告诉注册表此软件包是应公开发行还是受限制发行。仅适用于作用域包，默认为 restricted。如果您没有付费帐户，则必须使用发布与 –access public 发布有范围的软件包。 [–otp &lt;otpcode&gt;] 如果您在 auth-and-writes 模式下启用了双重身份验证，那么您可以为此提供来自身份验证器的代码。如果您不包括此文件，而您正在从 TTY 中运行，则会提示您。 [–dry-run] 从开始 npm@6，除了实际发布到注册表外，所有发布都可以完成。报告将要发布的内容的详细信息。 如果指定的注册表中已经存在软件包名称和版本组合，则失败。 一旦使用给定的名称和版本发布了软件包，即使使用 npm-unpublish 将其删除，该特定名称和版本组合也将永远无法再次使用。 npm adduser12npm adduser [--registry=url] [--scope=@orgname] [--always-auth] [--auth-type=legacy]aliases: login, add-user npm login是它的别名 发包过程第一次发包终端输入npm adduser,提示输入账号，密码和邮箱，然后将提示创建成功 非第一次发包在终端输入npm login，然后输入你创建的账号和密码，和邮箱，登陆 发布npm publish 撤销发布npm unpublish删除npm市场的包同名的24小时后才能重新发布 创建一个简单的模版管理工具(leon-cli)123456789101112131415161718192021Usage: leon cli [options]Options: -v --version output the version number -h, --help output usage informationCommands: init|i Create a new project by templates list|ls Show template lists use|u Switch template to use get|g Get one custom template, if only use &quot;leon get&quot; show all templates set|s Add or modify one custom template remove|rm Delete one custom templateUsages: leon init &lt;project-name&gt; : Init a project by template leon list : List all the templates leon get &lt;key&gt;? : Get one custom template leon set &lt;key&gt; &lt;value&gt; : Add or modify one custom template leon remove &lt;key&gt; : Delete one custom template leon use &lt;template-name&gt; : Switch template to use leon-cli详细代码]]></content>
      <categories>
        <category>npm</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nodom.js前端框架介绍]]></title>
    <url>%2FBlog%2F2020%2F01%2F01%2Fnodom%2F</url>
    <content type="text"><![CDATA[Nodom介绍 Nodom.js是什么？NoDom是一套轻量级的MVVM框架，以模块化为基础，用于构建SPA(Single Page Application)应用，主要服务于WebApp开发。提供基于数据驱动的渲染模式，页面变化只需修改数据即可实现。 目前Nodom.js兼容ES5，不支持ie浏览器（Edge除外） nodom官网：NoDom-数据驱动渲染MVVM框架 模块简介模块是Nodom的核心内容，Nodom开发的每个应用都是从模块开始，所有页面由模块组成，一个页面是一个模块，可能嵌套多个子模块。 模块主要包含两个部分：模版和数据 模版用于基本元素的编写，数据用于对模版的渲染，其中模版分为三种方式引入:元素、模版串、模版文件。 数据分为两种引入方式:数据对象和数据文件，模版文件和数据文件可以在模块初次使用时动态加载。 用法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;!-- 基本用法 --&gt;&lt;div class="root"&gt; 我是_&#123; name &#125;_，_&#123;age&#125;_ 岁. &lt;br&gt; 是&lt;span x-if="age&gt;10"&gt;成年人&lt;/span&gt; &lt;span x-else&gt;未成年人&lt;/span&gt;&lt;/div&gt;&lt;script&gt; DD.createModule(&#123; name: 'module1', el: '.root', data: &#123; age: 10, name: 'nodom', &#125; &#125;);&lt;/script&gt;&lt;!-- 文件加载 --&gt;&lt;!-- 请注意配置DD.config.appPath属性，路径以相对路径给出，如DD.config.appPath='/yourapp/app/'，创建模块时templateUrl设置为view/view1.html，调用时，NoDom会对两部分进行合并，从/yourapp/app/view/view1.html加载，请注意路径不要用多余的/。数据需给定url完整地址，可以是一个http响应，也可以是一个json数据文件。 --&gt;&lt;div class="root"&gt;&lt;/div&gt;&lt;script&gt; DD.createModule(&#123; el:'.root', /*请修改dataUrl和templateUrl*/ dataUrl:'datapath/dataname.json', templateUrl:'viewpath/viewname.html'&#125;);&lt;/script&gt;&lt;!-- 模块嵌套 --&gt;&lt;div class="root"&gt;&lt;/div&gt;&lt;script&gt; DD.createModule(&#123; el: '.root', /*用template模版串作为模版，模块中都不使用数据*/ template: '&lt;div style="border:1px solid #999"&gt;这是父模块&lt;div class="code31"&gt;&lt;/div&gt;&lt;div class="code32"&gt;&lt;/div&gt;&lt;/div&gt;', modules: [ /*子模块1，也是采用模版串*/ &#123; template: '&lt;div style="border:2px solid #900;margin:5px 0;"&gt;这是内部的子模块1&lt;/div&gt;', el: '.code31', &#125;, /*子模块2，也是采用模版串*/ &#123; template: '&lt;div style="border:2px solid #009"&gt;这是内部的子模块2&lt;/div&gt;', el: '.code32' &#125;] &#125;);&lt;/script&gt;&lt;!-- 模块通信 --&gt;&lt;!-- 每个模块都可以通过NoDom提供消息机制与兄弟模块、父模块和子模块进行通信，主要通过broadcast方法(广播消息)和send方法(定向发送)、onReceive钩子处理收到的消息。 --&gt;&lt;div class="root"&gt;&lt;/div&gt;&lt;script&gt; DD.createModule(&#123; /*给模块设置名字，方便在收到消息时针对不同模块做不同操作*/ name: 'module1', el: '.mod1', templateUrl: 'view/tutorial/module/communication.html', data: &#123; smsg: '', rmsg: '' &#125;, /*消息接收钩子*/ onReceive: function (module, data) &#123; this.data.rmsg = '来自' + module + '的消息：' + data.smsg; &#125;, methods: &#123; /*发送消息方法，由send按钮的e-click指定*/ sendMsg: function () &#123; /*broadcast为模块方法，用来向外部发送消息*/ this.broadcast(this.data); &#125; &#125;, modules: [&#123; name: 'module2', el: '.code41', data: &#123; smsg: '', rmsg: '' &#125;, onReceive: function (module, data) &#123; this.data.rmsg = '来自' + module + '的消息：' + data.smsg; &#125;, methods: &#123; sendMsg: function () &#123; this.broadcast(this.data); &#125; &#125; &#125;, &#123; name: 'module3', el: '.code42', data: &#123; smsg: '', rmsg: '' &#125;, onReceive: function (module, data) &#123; this.data.rmsg = '来自' + module + '的消息：' + data.smsg; &#125;, methods: &#123; sendMsg: function () &#123; this.broadcast(this.data); &#125; &#125; &#125;] &#125;);&lt;/script&gt; 模型模型是Nodom的提供者，用于管理整个模块的数据 注意：模型数据对象必须为json object，如果为数组，数组元素也必须是json object。view只能使用x-model指令指定的模型数据(如果没有x-model指令，则向上取第一个父view带x-model指令指定的模型数据)，不能跨x-model指令取数据。 表达式Nodom中，双大括号 _{}_ 里面的内容会被解析成表达式。表达式项主要用于获取数据项，计算并渲染到DOM中。表达式支持“(”、“)”、 “*”、 “/”、 “+” 、 “-”、 “&gt;”、 “&lt;”、 “&gt;=”、 “&lt;=”、 “==”、 “===”、 “&amp;&amp;”、 “||” 算数逻辑运算和过滤器运算符“|”。其中过滤器运算符“|”运算法优先级仅低于括号()运算法。 12345678910111213141516171819202122&lt;div class='result code1'&gt; &lt;div&gt;(3+4)/5的结果是:_&#123;(3 + 4) / 5&#125;_&lt;/div&gt; &lt;div&gt;商品名:_&#123; name &#125;_&lt;/div&gt; &lt;div&gt;商品价格：_&#123; price &#125;_&lt;/div&gt; &lt;div&gt;商品折扣价:_&#123; price*discount&#125;_&lt;/div&gt; &lt;!--引入过滤器，把计算结果转换为货币--&gt; &lt;div&gt;商品折扣价(精确到分):_&#123;(price * discount) | currency:¥&#125;_&lt;/div&gt; &lt;div&gt;生产日期是:_&#123; genDate| date:'yyyy-MM-dd'&#125;_&lt;/div&gt; &lt;div&gt;是否是低价商品:_&#123; price&lt;30&#125;_&lt;/div&gt; &lt;div&gt;是否是低价商品并且还有折扣:_&#123; price&lt;30 &amp;&amp; discount !== undefined &#125;_&lt;/div&gt;&lt;/div&gt;&lt;script&gt; DD.createModule(&#123; el: '.code1', data: &#123; price: 20, discount: 0.855, /*折扣*/ name: '测试商品', genDate: (new Date()).getTime() /*生产日期*/ &#125; &#125;);&lt;/script&gt; 过滤器过滤器以“|”来分隔待过滤内容和过滤器方法，如content|filtermethod，其中date、currency、number、tolowercase、touppercase主要用于表达式过滤，orderBy过滤器主要用于配合数组排序，select用于数组元素过滤。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;div class="root"&gt; &lt;!-- date --&gt; &lt;div class="time"&gt; &lt;!--注意日期格式两边的单引号--&gt; &lt;div&gt;当前日期是:_&#123;date1|date:'yyyy/MM/dd'&#125;_&lt;/div&gt; &lt;div&gt;当前时间是:_&#123;date1|date:'HH:mm:ss'&#125;_&lt;/div&gt; &lt;div&gt;当前日期和时间是:_&#123;date1|date:'yyyy-MM-dd HH:mm:ss'&#125;_&lt;/div&gt; &lt;/div&gt; &lt;!-- currency --&gt; &lt;div class="currency"&gt; &lt;!--默认货币为¥--&gt; &lt;div&gt;商品价格是:_&#123;price|currency&#125;_&lt;/div&gt; &lt;div&gt;商品价格是:_&#123;price|currency:$&#125;_&lt;/div&gt; &lt;/div&gt; &lt;!-- number --&gt; &lt;div class="number"&gt; &lt;div&gt;保留3位小数:_&#123;progress|number:3&#125;_&lt;/div&gt; &lt;div&gt;保留0位小数:_&#123;progress|number:0&#125;_&lt;/div&gt; &lt;/div&gt; &lt;!-- tolowercase／touppercase --&gt; &lt;div class="lower_uppercase"&gt; &lt;div&gt;转换为小写字母:_&#123;name|tolowercase&#125;_&lt;/div&gt; &lt;div&gt;转换为大写字母:_&#123;name|touppercase&#125;_&lt;/div&gt; &lt;/div&gt; &lt;!-- orderBy --&gt; &lt;div class='orderBy'&gt; 升序排序 &lt;ul&gt; &lt;li x-repeat='rows|orderBy:name'&gt;_&#123;name&#125;_'s address is _&#123;addr&#125;_&lt;/li&gt; &lt;/ul&gt; 降序排序 &lt;ul&gt; &lt;li x-repeat='rows|orderBy:name:desc'&gt;_&#123;name&#125;_'s address is _&#123;addr&#125;_&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!-- select --&gt; &lt;div class='select'&gt; &lt;!--select结合repeat指令使用--&gt; &lt;div class='imp'&gt;odd用法&lt;/div&gt; &lt;ul&gt; &lt;li x-repeat='rows|select:odd'&gt;_&#123;name&#125;_'s address is _&#123;addr&#125;_&lt;/li&gt; &lt;/ul&gt; even用法 &lt;ul&gt; &lt;li x-repeat='rows|select:even'&gt;_&#123;name&#125;_'s address is _&#123;addr&#125;_&lt;/li&gt; &lt;/ul&gt; range用法 &lt;ul&gt; &lt;li x-repeat='rows|select:range:1:3'&gt;_&#123;name&#125;_'s address is _&#123;addr&#125;_&lt;/li&gt; &lt;/ul&gt; index用法 &lt;ul&gt; &lt;li x-repeat='rows|select:index:1:3'&gt;_&#123;name&#125;_'s address is _&#123;addr&#125;_&lt;/li&gt; &lt;/ul&gt; v用法 &lt;ul&gt; &lt;li x-repeat="rows|select:yang"&gt;_&#123;name&#125;_'s address is _&#123;addr&#125;_&lt;/li&gt; &lt;/ul&gt; &#123;prop:v&#125;用法，这里的参数必须为正确的json串，比如yang是字符串，需在两边添加引号 &lt;ul&gt; &lt;li x-repeat="rows|select:&#123;addr:'yang'&#125;"&gt;_&#123;name&#125;_'s address is _&#123;addr&#125;_&lt;/li&gt; &lt;/ul&gt; func用法 &lt;ul&gt; &lt;li x-repeat='rows|select:func:selectArr'&gt;_&#123;name&#125;_'s address is _&#123;addr&#125;_&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; DD.createModule(&#123; el: '.root', data: &#123; date1: (new Date()).getTime(), price: 15.323, progress: 35.89992, name: 'Hello world!', rows: [ &#123; name: 'yang', addr: 'chengdu' &#125;, &#123; name: 'zhangs', addr: 'mianyang' &#125;, &#123; name: 'NoDom', addr: 'luoyang' &#125;, &#123; name: 'hello', addr: 'beijing' &#125;, ], &#125;, methods: &#123; selectArr: function (arr) &#123; var a = []; //过滤出name为yang的数组元素 arr.forEach(function (item) &#123; if (item.name === 'yang') &#123; a.push(item); &#125; &#125;); return a; &#125; &#125; &#125;);&lt;/script&gt; 指令指令主要包括：model, repeat, if/else, class, show, field(双向绑定), validity(校验), router(路由), 用法是 x-指令名称，如x-model。 model指令model指令用于给view绑定数据，数据采用层级关系，如:需要使用数据项data1.data2.data3，可以直接使用data1.data2.data3，也可以分2层设置分别设置x-model=’data1’，x-model=’data2’，然后使用数据项data3。 例子: model指令 repeat指令repeat指令用于给按照绑定的数组数据重复生成多个相同的view，每个view由指定数组索引对应的数据对象或数据进行渲染。使用方式为x-repeat=’items|filter’,其中items为json数组，filter为过滤器。 例子：repeat指令 if/else指令if/else指令用于进行条件渲染，如果if指令对应条件为真，则渲染该节点下的子节点，如果设置else指令，则条件为假时，渲染else指令对应节点的子节点。其中nodom不支持if…elseif,需要在else中嵌套 例子：if/else指令 class指令class指令用于按条件给view添加或移除css class。使用方式为x-class=’{class1:condition1,class2:condition2,…}’，当满足condition1时，添加class1,反之则移除class1，condition2处理方式相同。配置内容需符合json格式。 例子：class指令 show指令show指令用于显示或隐藏view，如果show对应的条件为真，则显示该view，否则隐藏该view。使用方式为x-show=’condition’。 例子：show指令 field指令field指令用于绑定form表单下的输入类型元素，如input、select、textarea等，可以实现输入元素与数据项之间的双向绑定。 其中：单选框radio，多个radio的x-field必须设置为同一个数据项，同时需设置value属性，该属性与数据项可能选值保持一致复选框checkbox，checkbox除了设置x-field外，还需要设置yes-value 和 no-value 属性，分别对应为选中时x-field对应数据项的值和未选中时的值。下拉列表select，option可以由给定数据用repeat生成，select设置x-field即可。 例子：field指令 validity指令validity指令用于form表单的数据项校验，该指令对应的view必须放置于form元素下才能正常工作，使用方式为x-validity=’fieldname’,fieldname对应输入框的name属性，表示针对该输入框进行校验，仅支持html5规范中支持的校验规则，包括required、min、max、pattern、type。使用该指令包，系统会自动生成DD.$validity对象，DD.$validity.check()方法可用于检测对应的form校验是否通过。 例子：validity指令 router指令路由用于管理模块的加载模块和模块间的切换，类似于（但不限于）一个超链接操作后执行页面切换。目前仅支持html5的pushstate和popstate方法，所以路由的支持需要浏览器支持html5。 浏览器刷新 路由切换通过pushstate修改浏览器地址，如www.yourdomain.com/route1/xxx，而你的网站不存在此资源，这个时候进行刷新，服务器会返回404错误，为了服务器能正常返回，可以在服务器配置404错误跳转页面，请参考各应用服务器配置说明。为解决该问题，需要在页面中得到服务器返回的路由路径，并调用DD.Router.start方法进行路由跳转 参数路由 路由可以带参数进行传递,以“/:参数名”方式进行定义，如/path/:param1/:param2，使用时x-route=’/path/:v1/:v2’，这样在当前模块可以使用$route.data[‘param1’] 得到v1。 路由嵌套 路由设置子路由，在设置x-route指令时，需要从根路由到子路由的每一级路径合并在一起。如父路由r1路径为“/route1”，r1的子路由r2路径为“/route2”,r2的子路由r3的路径为“/route3”，则x-route=’/route1/route2/route3’才能访问到路由r3，加载方式为，先加载并渲染r1对应的模块，然后加载并渲染r2对应的模块，最后加载并渲染r3对应的模块。 切换效果设置 路由切换支持动画效果，NoDom支持左右滑动的切换效果，需在路由使用前设置DD.Router.switch.style=’slide’，该配置项设置路由切换效果为滑动，默认为none，DD.Router.switch.switcType=’0.5s’，该配置为滑动时长为0.5秒，默认为1s。 路由创建 可通过DD.createRoute(config)创建一个或多个路由对象。config可以为一个参数对象，返回创建的路由，也可以为参数对象数组，无返回。参数对象配置参考配置对象参数说明。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156&lt;div&gt; &lt;div class="root"&gt;当前时间:_&#123;date1|date:'yyyy/MM/dd'&#125;_&lt;/div&gt; &lt;a x-route='/router' x-class="&#123;cls1:'page1'&#125;" active='_&#123;page1&#125;_'&gt;page1&lt;/a&gt; &lt;div x-router&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; DD.config.appPath = '/examples/route/pages/'; DD.config.routerPrePath = '/route'; DD.createModule(&#123; name: 'mainModule', el: '.root', root: true, data: &#123; page1: true, page2: false, date1: (new Date()).getTime(), x: &#123; y: &#123; z: 1 &#125; &#125; &#125;, methods: &#123; &#125; &#125;); DD.createModule([&#123; name: 'tdir_router', templateUrl: '/router/router.html', data: &#123; routes: [&#123; title: '路由用法1-基本用法', path: '/router/route1', active: true &#125;, &#123; title: '路由用法2-路由参数用法', path: '/router/directive/route2', active: false &#125;, &#123; title: '路由用法3-路由嵌套用法', path: '/router/route3', active: false &#125; ] &#125;, delayInit: true, &#125;, &#123; name: 'r_pmod1', templateUrl: 'router/router1.html', data: &#123; home: true, list: false, data: false &#125;, methods: &#123; onFirstRender: function () &#123; // console.log(this); &#125; &#125; &#125;, &#123; name: 'r_pmod2', templateUrl: 'router/router2.html', data: &#123; routes: [&#123; title: '首页', path: '/router/directive/route2/rparam/home/1', active: true &#125;, &#123; title: '列表', path: '/router/directive/route2/rparam/list/2', active: false &#125;, &#123; title: '数据', path: '/router/directive/route2/rparam/data/3', active: false &#125; ] &#125; &#125;, &#123; name: 'r_pmod3', templateUrl: 'router/router3.html' &#125;, &#123; name: 'r_mod1', template: "&lt;div&gt;这是首页,路径是_&#123;$route.path&#125;_&lt;/div&gt;" &#125;, &#123; name: 'r_mod2', template: "&lt;div&gt;这是商品列表页,路径是_&#123;$route.path&#125;_&lt;/div&gt;" &#125;, &#123; name: 'r_mod3', template: "&lt;div&gt;这是数据页,路径是_&#123;$route.path&#125;_&lt;/div&gt;" &#125;, &#123; name: 'r_mod4', template: "&lt;div test='1'&gt;这是_&#123;$route.data.page&#125;_页,编号是_&#123;$route.data.id&#125;_&lt;/div&gt;" &#125;, &#123; name: 'r_mod5', template: "&lt;div class='code1'&gt;路由r1加载的模块&lt;dir x-router&gt;&lt;/div&gt;&lt;/div&gt;" &#125;, &#123; name: 'r_mod6', template: '路由r2加载的模块' &#125;]); DD.createRoute(&#123; path: '/router', module: 'tdir_router', routes: [&#123; path: '/route1', module: 'r_pmod1', routes: [&#123; path: '/home', module: 'r_mod1', useParentPath: true &#125;, &#123; path: '/list', module: 'r_mod2', useParentPath: true &#125;, &#123; path: '/data', module: 'r_mod3', useParentPath: true &#125;], onLeave: function (model) &#123; // console.log(this,model); &#125; &#125;, &#123; path: '/directive/route2', module: 'r_pmod2', onEnter: function () &#123; // console.log('route2'); &#125;, routes: [&#123; path: '/rparam/:page/:id', module: 'r_mod4', onEnter: function () &#123; // console.log('route2/rparam'); &#125; &#125;] &#125;, &#123; path: '/route3', module: 'r_pmod3', routes: [&#123; path: '/r1', module: 'r_mod5', routes: [&#123; path: '/r2', module: 'r_mod6' &#125;] &#125;] &#125;] &#125;);&lt;/script&gt; eventNoDom提供了专门的事件类DD.Event，用于处理view的事件操作。类似于指令用法，事件用e-开头，如e-click，e-touchstart等，事件支持所有的html元素标准事件。事件处理方法必须在模块的methods中定义，事件方法会自带三个参数 event(事件)、viewdata(触发事件的view对应的数据对象)、view(视图)，this指向model(模型)。 NoDom提供了触屏操作事件，包括tap(点击)、swipeleft(左滑)、swiperight(右滑)、swipeup(上滑)、swipedown(下滑)。 NoDom支持delg(事件代理)、nopopo(禁止冒泡)、once(单次执行)配置。 123456789101112131415161718192021222324252627282930313233&lt;div class='result code1'&gt; &lt;div class='colorimp'&gt;点击后查看控制台输出内容&lt;/div&gt; &lt;button e-click='clickdiv'&gt; 点击我试试 &lt;/button&gt; &lt;div class='colorimp'&gt;点击下面的商品，查看控制台输出内容。&lt;/div&gt; &lt;ul&gt; &lt;!--这儿做了事件代理，事件会注册到ul元素上--&gt; &lt;li x-repeat='datas' e-click='clickli:delg'&gt; _&#123;name&#125;_ 的价格是_&#123;price&#125;_,折扣是_&#123;discount&#125;_。 &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; DD.createModule(&#123; el: '.code1', data: &#123; datas: [ &#123; name: '酷炫夹克', price: 200, discount: 0.6 &#125;, &#123; name: '运动棉袜', price: 8, discount: 0.9 &#125;, &#123; name: '钥匙扣', price: 15, discount: 0.7 &#125; ] &#125;, methods: &#123; clickdiv: function (e, data, view) &#123; console.log(e, data, view); &#125;, clickli: function (e, data, view) &#123; console.log(e, data, view); &#125; &#125; &#125;);&lt;/script&gt; API详见官网API，Nodom API]]></content>
      <categories>
        <category>js framework</category>
      </categories>
      <tags>
        <tag>js框架, MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Hooks分享]]></title>
    <url>%2FBlog%2F2019%2F12%2F12%2FReacthooks%2F</url>
    <content type="text"><![CDATA[React Hooks分享React hooks是什么 1、类组件class Counter extends Component{ render(){ return “hello world” } }类组件的优点：拥有state状态 需要生命周期函数 需要副作用操作 函数组件`const Counter=()=&gt;{ return “hello world” } `2、函数式优点： 简单易懂 符合UI=f（state）的原则 函数式编程 react Hooks 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数React hooks官网：https://zh-hans.reactjs.org/docs/hooks-intro.html 一、useState介绍useState返回的值：const [count,setCount]=useState(0);const [属性, 操作属性的方法] = useState(默认值);相当于一个解构：const state=useState(0); const count=state[0]; const setCount=state[1]; useState返回结果可以任意取名，useState可以多个使用使用useState规则： Hook 在每次渲染时都按照相同的顺序被调用那么 React 怎么知道哪个 state 对应哪个 useState？答案是 React 靠的是 Hook 调用的顺序。因为我们的示例中，Hook 的调用顺序在每次渲染中都是相同的，所以它能够正常工作结论：不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们使用Hook的规则：1、只在最顶层使用 Hook2、在 React 的函数组件中调用 Hook3、在自定义 Hook 中调用其他 Hook遵循此规则3、不要在普通的 JavaScript 函数和React class组件中调用 Hook4、自定义hook，假设任何以 「use」 开头并紧跟着一个大写字母的函数就是一个 Hook，以便于react辨别函数内部可以调用其他的 Hookstate永远都是新的值这一点同我们过去class组件中的state是完全不一样的。在class组件中，state一直是挂载在当前实例下，保持着同一个引用。而在函数式组件中，没有this。不管你的state是一个基本数据类型（如string、number），还是一个引用数据类型（如object），只要是通过useState获取的state，每一次render，都是新的值。 useState返回的状态更新方法，只是让下一次render时的state能获取到当前最新的值。而不是保持一个引用、更新那个引用值。 二、useEffect介绍useEffect可以让你在函数组件中执行副作用操作：在 React 更新 DOM 之后运行一些额外的代码。比如发送网络请求，手动变更 DOM，事件监听，定时器……useEffect 在渲染结束时执行，所以不会阻塞浏览器渲染进程useEffect = componentDidMount + componentDidUpdate + componentWillUnmount ；useEffect可以在一个组件中写多个，按顺序执行 useEffect 模拟 componentDidMount 和 componentWillUnmount useEffect (() =&gt; { // 只有DidMount调用这里 return () =&gt; { // 只有unmount的时候走这里 } }, [])；Didmount：如果想执行只运行一次的 effect（仅在组件挂载和卸载时执行），可以传递一个空数组（[]）作为第二个参数。这就告诉 React 你的 effect 不依赖于 props 或 state 中的任何值，所以它永远都不需要重复执行Unmount: effect 中return是 effect 可选的清除机制。每个 effect 都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。它们都属于 effect 的一部分 useEffect 模拟 componentDidUpdateuseEffect 会在每次渲染后都执行在第一次渲染之后和每次更新之后都会执行。去掉首次渲染就可以实现componentDidUpdateconst mounted = useRef();useEffect(() =&gt; { if (!mounted.current) { mounted.current = true; } else { // do componentDidUpdate } })因为useEffect 会在每次渲染后都执行，因此需要通过 useEffect 的第二个参数告诉 React 用到了哪些外部变量（第二个参数不是必须的）第二个参数[param1,param2,param3,…]是或的关系，只要其中一个改变就触发更新 因此需要开发者通过 useEffect 的第二个参数告诉 React 用到了哪些外部变量而是effect本应该每次render都触发，但因为effect内部依赖了外部数据，外部数据不变则内部effect执行无意义。因此只有当外部数据变更时，effect才会重新触发。useEffect规则：只要内部使用了某个外部变量，函数也好、变量也好，都应该填写到依赖配置中useEffect的优势：Class组件中是按照生命周期写逻辑componentDidMount 和 componentDidUpdate，componentWillUnmount你可以使用多个 effect，将不相关逻辑分离到不同的 effect 三、useLayoutEffect介绍useLayoutEffect在浏览器重新绘制页面布局前useLayoutEffect内部的更新将会同步刷新useLayoutEffect 可以看作是 useEffect 的同步版本，但是不同的是：1、useEffect，使用useEffect不会阻塞浏览器的重绘2、useLayoutEffect, 使用useLayoutEffect，会阻塞浏览器的重绘。如果你需要手动的修改Dom，推荐使用useLayoutEffect。因为如果在useEffect中更新Dom，useEffect不会阻塞重绘，用户可能会看到因为更新导致的闪烁3、因为 useLayoutEffect 是同步的，如果我们要在 useLayoutEffect 调用状态更新，或者执行一些非常耗时的计算，可能会导致 React 运行时间过长，阻塞了浏览器的渲染 四、useContext介绍useContext的使用：可访问全局状态，避免一层层的传递状态。`const ThemeContext = React.createContext(‘light’); &lt;ThemeContext.Provider value={theme}&gt; &lt;/ThemeContext.Provider&gt; Hooks之前的写法：&lt;ThemeContext.Consumer&gt;{theme =&gt; ({theme})}&lt;/ThemeContext.Consumer&gt; Hooks之后的写法const theme = useContext(ThemeContext);{theme}` 五、useRef介绍 useRef： const refContainer = useRef(initialValue);useRef 返回一个可变的 ref { current: initValue } 对象，其 .current 属性被初始化为传递的参数（initialValue）。该对象在整个生命周期中保持不变。从本质上讲，useRef就像一个“盒子”，可以在其.current财产中保持一个可变的价值。useRef() Hooks 不仅适用于 DOM 引用。 “ref” 对象是一个通用容器，其 current 属性是可变的，可以保存任何值（可以是元素、对象、基本类型、甚至函数），类似于类上的实例属性。 useRef 主要有两个使用场景：1、获取子组件或者 DOM 节点的句柄2、渲染周期之间的共享数据的存储使用场景：获取上一轮的 props 或 state通过 useEffect 在组件渲染完毕后再执行的特性，再利用 useRef 的可变特性，让 usePrevious 的返回值是 “上一次” Render 时的值function usePrevious(value) { const ref = useRef(); useEffect(() =&gt; { ref.current = value; }); return ref.current; } 六、useCallback介绍 useCallback都会在组件第一次渲染的时候执行，之后会在其依赖的变量发生改变时再次执行，useCallback返回缓存inline函数。防止因属性更新时生成新的函数导致子组件重复渲染useCallback接受函数和一个数组输入，并返回的一个缓存版本的回调函数，仅当重新渲染时数组中的值发生改变时，才会返回新的函数实例，这也就解决我们上面提到的优化子组件性能的问题，并且也不会有上面繁琐的步骤。返回值为 回调函数，第一个参数为一个函数，第二个为一个数组，只有内部元素变化，返回的回调函数才会被重新创建componentDidUpdate(prevProps) { if ( this.props.count !== prevProps.count &amp;&amp; this.props.step !== prevProps.step) { this.props.fetchData(); } }useCallback(callback: T, deps: DependencyList): callback把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时，它将非常有用。 七、React.memo介绍在 Fucntion Component 中，React.memo 等效于 PureComponent，浅比较 props。用 memo 做 PureRender === 函数组件中的shouldComponentUpdate:const Child = memo((props) =&gt; { return …… }, (nextProps, prevProps) =&gt; { // 做我们想做的事情，类似shouldComponentUpdate }) 使用 memo 包裹的组件，会在自身重渲染时，对每一个 props 项进行浅对比，如果引用没有变化，就不会触发重渲染。 八、useMemo介绍const a = useMemo(() =&gt; memorizeValue, deps) useMemo返回缓存数据和计算结果。用 useMemo 做局部 PureRenderuseMemo返回的是一个缓存的值。也就是仅当重新渲染时数组中的值发生改变时，回调函数才会重新计算缓存数据，这可以使得我们避免在每次重新渲染时都进行复杂的数据计算。因此我们可以认为:useCallback(fn, input) 等同于 useMemo(() =&gt; fn, input)如果没有给useMemo传入第二个参数，则useMemo仅会在收到新的函数实例时，才重新计算，需要注意的是，React官方文档提示我们，useMemo仅可以作为一种优化性能的手段，不能当做语义上的保证，这就是说，也会React在某些情况下，即使数组中的数据未发生改变，也会重新执行。Hooks性能在现代浏览器中，与类相比，闭包的原始性能没有显著差异，除了在极端情况下。 此外，考虑到Hooks的设计在以下几个方面更有效：1、钩子避免了类所需的大量开销，例如在构造函数中创建类实例和绑定事件处理程序的成本。2、使用Hooks的惯用代码不需要深层组件树嵌套，这在使用高阶组件，渲染道具和上下文的代码库中很常见。 使用较小的组件树，React的工作量较少。Hooks优势1、方便复用状态逻辑2、副作用的关注点分离3、函数组件无 this 问题 九、useReduceruseReducer主要用于更新复杂逻辑的状态useReducers可以传入三个参数，第一个参数就是形如(state,action) =&gt; newState这样的reducer，第二参数是初始化默认值，第三个参数是一个函数，接受第二个参数进行计算获取默认值(可选)。seReducer接收三个参数，reducer函数，initialArg初始值，init惰性初始值函数。reducer函数和Redux的reducer类似，接收state，以及action。返回更新后的state。如果传入三个参数，init(initialArg)将作为初始值。useReducer在复杂场景下比useState更适用。指定初始stateuseReducer的第二个参数可以指定初始的state惰性初始化如果指定useReducer的第三个参数，useReducer的初始值会被设置为init(initialArg)React 会确保 dispatch 函数的标识是稳定的，并且不会在组件重新渲染时改变。]]></content>
  </entry>
  <entry>
    <title><![CDATA[BOM（Browser Object Model）浏览器对象模型]]></title>
    <url>%2FBlog%2F2019%2F03%2F21%2FBOM%2F</url>
    <content type="text"><![CDATA[1.定义1.1 BOM是什么？ BOM（Browser Object Model）即浏览器对象模型。 BOM提供了独立于内容 而与浏览器窗口进行交互的对象,其核心对象是window； BOM由一系列相关的对象构成，并且每个对象都提供了很多方法与属性； BOM缺乏标准，JavaScript语法的标准化组织是ECMA，DOM的标准化组织是W3C，BOM最初是Netscape浏览器标准的一部分。W3C 为了把浏览器中JavaScript 最基本的部分标准化，已经将BOM的主要方面纳入了HTML5 的规范中。 1.2 BOM包含什么？ 2.window对象2.1 全局作用域BOM的核心对象是window，它表示浏览器的一个实例。在浏览器中，window对象有双重角色，它既是通过javascript访问浏览器窗口的一个接口，又是ECMAScript规定的Global对象。 因此，所有全局作用域中声明的变量、函数都会变成window对象的属性和方法。1234567891011121314 var age=26;//这里定义的全局变量和全局函数被自动归在了window对象名下function sayAge()&#123; console.log(this.age);&#125;console.log(window.age);//26sayAge();//26 相当于window.sayAge()window.sayAge();//26 //全局变量和在window对象上直接定义属性的唯一区别：全局变量不能够通过delete操作符删除，而直接在window对象上定义的属性可以window.color=&apos;red&apos;;delete window.age;delete window.color;console.log(window.age);//26console.log(window.color);//undefined See the Pen ErrdKK by vivizhou0596 (@vivizhou0596) on CodePen. 1234567/*还要注意：尝试访问未声明的变量会抛出错误，但是通过查询window对象，可以知道某个可能未经声明的变量是否存在 *///这会抛出错误，因为oldValue未定义var newValue=oldValue;//这不会抛出错误，因为是一次属性查询var newValue=window.oldValue; 2.2 窗口关系及框架如果页面中包含框架，则每个框架都拥有自己的window对象，并且保存在frames集合中。在frames集合中，可以通过数值索引(从0开始，从左到右，从上到下)或者框架名称来访问相应的window对象。每个window对象都有一个name属性，其中包含着框架的名称。 可以通过window.frames[0]或者window.frames[“topFrame”]来引用上方的框架。不过，最好使用top，而不是window来引用这些框架。因为，top对象始终指向最高(最外)层的框架，也就是浏览器窗口。使用它可以确保在一个框架中正确地访问另一个框架。因为对于一个在框架中编写的任何代码来说，其中的window对象指向的都是那个框架的特定实例，而不是最高层的框架。 与top相对的另一个window对象是parent。parent对象始终指向当前框架的直接上层框架。 与框架有关的最后一个对象是self，它始终指向window。self和window对象可以互换使用。 在使用框架的情况下，浏览器中会存在多个Global对象。在每个框架中定义的全局变量会自动成为框架中window对象的属性。由于每个window对象都包含原生类型的构造函数，因此每个框架都有一套自己的构造函数，这些构造函数一一对应，但并不相等。 ① 如果文档包含框架（frame 或iframe标签），浏览器会为HTML文档创建一个window对象，并为每个框架创建一个额外的window对象。 ② window.frames 返回窗口中所有命名的框架 ③parent是父窗口（如果窗口是顶级窗口，那么parent==self==top）； top是最顶级父窗口（有的窗口中套了好几层frameset或者iframe）； self是当前窗口（等价window）； opener是用open方法打开当前窗口的那个窗口； 2.3窗口位置与大小2.3.1窗口位置窗口位置：窗口相对于屏幕左边和上边的位置screenLeft和screenTop属性：IE、Safari、Opera、ChromescreenX和screenY属性：Firefox、Safari、Chrome 在IE、Opera中，screenLeft和screenTop中保存 的是从屏幕左边和上边到由window对象表示的页面可见区域的距离在Chrome、Firefox和Safari中，screenY或screenTop中保存的是整个浏览器窗口相对于屏幕的坐标值，即在窗口的y轴坐标为0时返回0。 123var leftPos = (typeof window.screenLeft === &apos;number&apos;) ? window.screenLeft : window.screenX;var rightPos = (typeof window.screenTop === &apos;number&apos;) ? window.screenTop : window.screenY; 2.3.1窗口大小跨浏览器确定一个窗口的大小不是一件简单的事。IE9+、Firefox、Safari、Opera 和Chrome 均为此提供了4 个属性：innerWidth、innerHeight、outerWidth 和outerHeight。红宝书《JavaScript高级程序设计》上对这几个属性的描述如下： 1在IE9+、 Safari 和 Firefox、Opera中， outerWidth 和outerHeight 返回浏览器窗口本身的尺寸，而 innerWidth 和 innerHeight则表示该容器中页面视图区的大小(减去边框宽度)。在 Chrome中相应宽高返回相同的值，即视 口( viewport)大小而非浏览器窗口大小。 随手在windows上的Chrome上测试了一下，发现在并不如书中所述，并且在窗口处于最大化和最小化时表现也不一致，因此这些属性对于不同系统不同版本的浏览器表现可能都不一致，不能作为精确值使用。12345678var pageWidth=window.innerWidth, pageHeight=window.innerHeight, windowWdith=window.outerWidth, windowHeight=window.outerHeight; document.write(&quot;innerWidth=&quot;+pageWidth+&quot;&amp;emsp;&amp;emsp;&quot;); document.write(&quot;innerHeight=&quot;+pageHeight+&quot;&lt;br /&gt;&quot;); document.write(&quot;outerWidth=&quot;+windowWdith+&quot;&amp;emsp;&amp;emsp;&quot;); document.write(&quot;outerHeight=&quot;+windowHeight); 2.4超时调用和间歇调用(定时器)javascript是单线程语言，但允许通过设置超时值和间歇值来设定代码在特定时刻执行 超时调用（执行一次）：是在指定的时间过后执行代码 间歇调用（重复执行）：每隔指定的时间就执行一次代码 超时调用：需要使用window对象的setTimeout()方法，接收两个参数：要执行的代码和以毫秒表示的时间。 第二个参数是一个表示等待多长时间的毫秒数，但经过该时间后指定的代码不一定执行。因为，javascript是一个单线程的解释器，因此一定时间内只能执行一段代码。第二个参数表示再过多长时间把当前任务添加到队列中。如果队列是空的，则代码会立刻执行，否则就要等待前面的代码执行完了以后再执行。 调用setTimeout()后，该方法会返回一个数值ID,表示超时调用。要取消未执行的超时调用计划，可以调用clearTimeout()方法并将相应的超时调用ID作为参数传递给它即可。 间歇调用：使用setInterval()方法 与超时调用类似，只不过它会按照指定的时间间隔重复执行代码，直到间歇调用被取消或者页面被卸载。它接收的参数与setTimeout()方法一样 demo1123456 //设置超时调用var timeoutId = setTimeout(function() &#123; alert(&quot;Hello world!&quot;);&#125;, 1000);//取消超时调用clearTimeout(timeoutId); demo21234567891011var num = 0;var max = 10;var intervalId = null;function incrementNumber() &#123; console.log(num++); if (num == max) &#123; clearInterval(intervalId); alert(&quot;Done&quot;); &#125;&#125;intervalId = setInterval(incrementNumber, 500); demo31234567891011121314/* 使用超时调用来实现 */ var num = 0; var max = 100; function incrementNumber() &#123; num++; if (num &lt; max) &#123; setTimeout(incrementNumber, 500); &#125; else &#123; alert(&quot;Done&quot;); &#125; &#125; setTimeout(incrementNumber, 500); 在使用超时调用时，没有必要跟踪超时调用ID，因为每次执行代码之后，如果不再设置另一次超时调用，调用就会自动停止。一般认为，使用超时调用来模拟间歇调用是一种最佳模式。间歇调用一般较少使用，因为后一个间歇调用可能会在前一个间歇调用结束之前启动 2.5系统对话框alert()、confirm()和prompt()浏览器通过alert()、confirm()和prompt()方法可以调用系统对话框向用户显示消息。系统对话框与在浏览器中显示的网页没有关系，也不包含HTML。它们的外观由操作系统及（或）浏览器设置决定，而不是由CSS 决定。此外，通过这几个方法打开的对话框都是同步和模态的。也就是说，显示这些对话框的时候代码会停止执行，而关掉这些对话框后代码又会恢复执行。1alert(&quot;Hello world!&quot;); confirm()方法用于显示一个带有指定消息和确认及取消按钮的对话框。判断用户点击了OK还是Cancel，可以检查confirm()方法返回的布尔值：true表示单击了OK，false表示单击了Cancel或单击了右上角的X按钮。 12345if (confirm(&quot;Are you sure?&quot;)) &#123; alert(&quot;I&apos;m so glad you&apos;re sure! &quot;);&#125; else &#123; alert(&quot;I&apos;m sorry to hear you&apos;re not sure. &quot;);&#125; prompt()方法用来生成一个”提示”框，用于提示用户输入一些文本。提示框除了显示OK和Cancel按钮之外 ，还会显示一个文本输入域，用来输入文本内容。该方法接收两个参数：要显示给用户的文本提示和文本输入域的默认值(可以是一个空字符串) 1234var result = prompt(&quot;What is your name? &quot;, &quot;&quot;);if (result !== null) &#123; alert(&quot;Welcome, &quot; + result);&#125; 3.Location对象location对象是一个很特殊的对象，因为它既是window对象的属性，也是document对象的属性；换句话说，window.location和document.location引用的是同一个对象。location对象的用处不只表现在它保存着当前文档的信息，还表现在它将URL解析为独立的片段，让开发人员可以通过不同的属性访问这些片段。下标列出了location对象的所有属性（省略了每个属性前面的location前缀）： 属性名 例子 说明 hash “#contents” 返回URL中的hash（#号后跟零或多个字符），如果URL中不包含散列，则返回空字符串 host “www.wrox.com:80&quot; 返回服务器名称和端口号（如果有） hostname “www.wrox.com&quot; 返回不带端口号的服务器名称 href “http:/www.wrox.com&quot; 返回当前加载页面的完整URL。而location对象的toString()方法也返回这个值 pathname “/WileyCDA/“ 返回URL中的目录和（或）文件名 port “8080” 返回URL中指定的端口号。如果URL中不包含端口号，则这个属性返回空字符串 protocol “http:” 返回页面使用的协议。通常是http:或https: search “?q=javascript” 返回URL的查询字符串。这个字符串以问号开头 查询字符串参数虽然上面的属性可以访问到location对象的大多数信息，但是其中访问URL包含的查询字符串的属性并不方便。尽管location.search返回从问号到URL末尾的所有内容，但是却没有办法逐个访问其中的每个查询字符串参数。因此可以创建一个函数，用以解析查询字符串，然后返回包含所以参数的一个对像。 123456789101112131415161718192021222324 function getQueryStringArgs()&#123; //取得查询字符串并去掉开头的问号 var qs = (location.search.length &gt; 0 ? location.search.substring(1) : &quot;&quot;), //保存数据的对象 args = &#123;&#125;, //取得每一项 items = qs.length ? qs.split(&quot;&amp;&quot;) : [], item = null, name = null, value = null, //在for 循环中使用 i = 0, len = items.length; //逐个将每一项添加到args 对象中 for (i=0; i &lt; len; i++)&#123; item = items[i].split(&quot;=&quot;); name = decodeURIComponent(item[0]); value = decodeURIComponent(item[1]); if (name.length) &#123; args[name] = value; &#125; &#125; return args;&#125; 3.1位置操作使用location对象可以通过很多方式来改变浏览器的位置。最常用的方式就是使用assign()方法并为它传递一个参数URL：1location.assign(&apos;http://www.wrox.com&apos;); 这样就可以打开新URL，并在浏览器的历史记录中生成一条记录。如果将location.href和window.location设置为一个URL值。也会以该值调用assign()方法。下面的两行代码的效果是一样的：12 window.location = &apos;http://www.wrox.com&apos;;location.href = &apos;http://www.wrox.com&apos;; 最常用的是设置location.href属性。修改location对象的其他属性也可以改变当前加载的页面：123456789101112//假设初始值URL为：http://www.wrox.com/WileyCDA//将URL修改为：http://www.wrox.com/WileyCDA/#sectionlocation.hash = &apos;#section&apos;;//将URL修改为：http://www.wrox.com/WileyCDA/?q=javascriptlocation.search = &apos;?q=javascript&apos;;//将URL修改为：http://www.wrox.com/WileyCDA/location.hostname = &apos;www.wrox.com&apos;;//将URL修改为：http://www.wrox.com/mydirlocation.pathname = &apos;mydir&apos;;//将URL修改为：http://www.wrox.com:8080/WileyCDA/location.port = 8080;// 每次修改location的属性（hash除外）都会以新URL重新加载 当通过上述任何一种方式修改URL后，浏览器的历史记录中就会生成一条新记录。要禁用这种行为可以使用replace()方法，这个方法只接收一个参数，既要导航到的URL，结果虽然导致浏览器位置变化，但不在历史记录中生成新记录。在调用replace()方法后，用户不能回到前一个页面，此时后退按钮将处于禁用状态：1location.replace(&apos;www.wrox.com&apos;); 与为重有关的最后一个方法是reload()，作用是重新加载当前显示的页面。如果调研那个reload()不传递任何参数，页面就以最有效的方式重载，也就是从浏览器缓存中冲洗加载；如果想强制从服务器重新加载，则需要：12location.reload(); //从页面加载location.reload(true); //从服务器加载 位于reload()方法后的代码可能会也可能不会执行，这要取决于网络延迟或系统资源等因素，因此，最好将reload()放在代码的最后一行。 4.Navigator对象最早由NetscapeNavigator2.0引入的navigator对象，现在已经成为识别客户端浏览器的事实标准。虽然其他浏览器也通过其他方式提供了相同或相似的信息（例如，IE 中的window.clientInformation和Opera 中的window.opera），但navigator 对象却是所有支持JavaScript 的浏览器所共有的。与其他BOM 对象的情况一样，每个浏览器中的navigator 对象也都有一套自己的属性。 Navigator属性虽然多，但是感觉都不太实用，列出几个在项目中实际用到的东西。 *1、navigator.appCodeName（不准确）：属性是一个只读字符串，声明了浏览器的代码名。 在所有以 Netscape 代码为基础的浏览器中，它的值是 &quot;Mozilla&quot;。为了兼容起见，在 Microsoft 的浏览器中，它的值也是 &quot;Mozilla&quot;，同时在safari在浏览器的console里运行navigator.appCodeName得出的结果还是&quot;Mozilla&quot;，所以这个看起来并不实用，因为IE、chrome、safari返回的都是“Mozilla”。 *2、navigator.appName（不准确）：返回所使用浏览器的名称。 由于兼容性问题，HTML5 规范允许该属性返回 &quot;Netscape&quot;。该属性并不一定能返回正确的浏览器名称。在基于 Gecko 的浏览器 （例如 Firefox）和基于 WebKit 的浏览器（例如 Chrome 和 Safari）中，返回的浏览器名称都是 &quot;Netscape&quot;。 *3、navigator.appVersion（已废弃）：属性可返回浏览器的平台和版本信息。 该属性是一个只读的字符串。该特性已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用该特性。 *4、navigator.platform：属性是一个只读的字符串，声明了运行浏览器的操作系统和（或）硬件平台。 可能的值有: &quot;Win32&quot;, &quot;Linux i686&quot;, &quot;MacPPC&quot;, &quot;MacIntel&quot;等。 *5、navigator.userAgent（用的最多，也可以说相对更准确）：属性是一个只读的字符串，声明了浏览器用于 HTTP 请求的用户代理头的值。 由于是各家浏览器厂商都想要自己的浏览器被其他的兼容，所以都会或多或少的加上一些其他的信息在里面。 5.History对象history对象记录了用户曾经浏览过的页面(URL)，并可以实现浏览器前进与后退相似导航的功能。 注意:从窗口被打开的那一刻开始记录，每个浏览器窗口、每个标签页乃至每个框架，都有自己的history对象与特定的window对象关联。 语法： window.history.[属性|方法]注意：window可以省略。 History 对象属性 属性 描述 length 浏览器历史列表中的URL数量 History 对象方法 方法 描述 back() 加载 history 列表中的前一个 URL。 forward() 加载 history 列表中的下一个 URL。 go() 根据当前所处的页面，加载 history 列表中的某个具体的页面。 HTML5引入了histtory.pushState()和history.replaceState()这两个方法，他们允许添加和修改history实体。同时，这些方法会和window.onpostate事件一起工作。pushState方法pushState()有三个参数:state对象，标题(现在是被忽略，未作处理)，URL(可选)。具体细节： state对象 –state对象是一个JavaScript对象，它关系到由pushState()方法创建出来的新的history实体。用以存储关于你所要插入到历史 记录的条目的相关信息。State对象可以是任何Json字符串。因为firefox会使用用户的硬盘来存取state对象，这个对象的最大存储空间为640k。如果大于这个数 值，则pushState()方法会抛出一个异常。如果确实需要更多的空间来存储，请使用本地存储。 title—firefox现在回忽略这个参数，虽然它可能将来会被使用上。而现在最安全的使用方式是传一个空字符串，以防止将来的修改。或者可以传一个简短的标题来表示state URL—这个参数用来传递新的history实体的URL，注意浏览器将不会在调用pushState()方法后加载这个URL。但也许会过一会尝试加载这个URL。比如在用户重启了浏览器后，新的url可以不是绝对路径。如果是相对路径，那么它会相对于现有的url。新的url必须和现有的url同域，否则pushState()将抛出异常。这个参数是选填的，如果为空，则会被置为document当前的url。 某种意义上来说，调用pushState()方法很像设置了window.location = “#foo”,这两者都会创建和激活另一个关联到当前document的history实体，但pushState()另外有一些优点： l 如果不需要，你可以不修改url。对比而言，设置window.location = “#foo”;仅产生新的history实体，如果你当前的hash不是#foo 2 你可以将任意的数据与你的新history实体关联。使用基于hash的方法，需要将所有相关的数据编码为一个短字符串。 注意，pushState()方法不会使hashchange时间发生，即使是新旧url只是hash不同。 replaceState()方法history.replaceState() 用起来很像pushState()，除了replaceState()是用来修改当前的history实体而不是创建一个新的。这个方法有时会很有用，当 你需要对某些用户行为作反应而更新一个state对象或者当前history实体时，可以使用它来更新state对象或者当前history实体的url。 popstate事件当history实体被改变时，popstate事件将会发生。如果history实体是有pushState和replaceState方法产生的，popstate事件的state属性会包含一份来自history实体的state对象的拷贝 详见window.onpopstate 读取当前的state当页面加载时，它可能会有一个非空的state对象。这可能发生在当页面设置一个state对象(使用pushState或者replaceState)之后用户重启了浏览器。当页面重新加载，页面将收到onload事件，但不会有popstate事件。然而，如果你读取history.state属性，将在popstate事件发生后得到这个state对象var currentState = history.state; 6.小结浏览器对象模型（BOM）以window 对象为依托，表示浏览器窗口以及页面可见区域。同时，window对象还是ECMAScript 中的Global 对象，因而所有全局变量和函数都是它的属性，且所有原生的构造函数及其他函数也都存在于它的命名空间下。本章讨论了下列BOM的组成部分。 在使用框架时，每个框架都有自己的window 对象以及所有原生构造函数及其他函数的副本。每个框架都保存在frames 集合中，可以通过位置或通过名称来访问。 有一些窗口指针，可以用来引用其他框架，包括父框架。 top 对象始终指向最外围的框架，也就是整个浏览器窗口。 parent 对象表示包含当前框架的框架，而self 对象则回指window。 使用location 对象可以通过编程方式来访问浏览器的导航系统。设置相应的属性，可以逐段或整体性地修改浏览器的URL。 调用replace()方法可以导航到一个新URL，同时该URL 会替换浏览器历史记录中当前显示的页面。 navigator 对象提供了与浏览器有关的信息。到底提供哪些信息，很大程度上取决于用户的浏览器；不过，也有一些公共的属性（如userAgent）存在于所有浏览器中。BOM 中还有两个对象：screen 和history，但它们的功能有限。screen 对象中保存着与客户端显示器有关的信息，这些信息一般只用于站点分析。history 对象为访问浏览器的历史记录开了一个小缝隙，开发人员可以据此判断历史记录的数量，也可以在历史记录中向后或向前导航到任意页面。 参考链接： react-router原理]]></content>
      <categories>
        <category>js 基础</category>
      </categories>
      <tags>
        <tag>js基础, -BOM, -浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[位操作符]]></title>
    <url>%2FBlog%2F2019%2F03%2F14%2Fbitwise-operators%2F</url>
    <content type="text"><![CDATA[原码, 反码, 补码 原码（True Form）使用高位作为符号位。最高位为0时表示正数，最高位为1时则表示为负数。其余位使用此数字数值本身二进制的绝对值表示。 原码的设计不便于加减运算。 反码（Ones’ Complement）使用高位作为符号位。最高位为0时表示正数，最高位为1时则表示为负数。正数的反码还是正数本身，负数的补码就是其绝对值相同的正数取反的结果。即在原码的基础上，符号位不变，其他位取反的结果。 反码的设计依然不便于加减运算。 补码（Twos’ Complement）使用高位作为符号位。最高位为0时表示正数，最高位为1时则表示为负数。正数的补码就是正数本身，负数的补码就是其原码取反加一的结果。补码设计的目的，就是讲将原二进制数，分一半做负数，而取反加一的规律则是在此设计的基础上归纳得来的。所以，使用“取反加一”来定义补码，是与设计相悖的。 补码的设计，方便了二进制的加减运算。 转换 正数：原码，反码，补码都一样。 负数： 原码和反码的相互转换：符号位不变，数值位按位取反 原码和补码的相互转换：符号位不变，数值位按位取反,末位再加1 已知补码，求原码的负数的补码：符号位和数值位都取反，末位再加1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// 8的八位原码，反码，补码// 0000 1000// -8的八位原码，反码，补码// 原：1000 1000// 反：1111 0111// 补：1111 1000// 实现一个二进制类：function Binary(num, opt)&#123; this.num = num; this.opt = opt; this.binary_str = num.toString(2);&#125;Binary.prototype.getTrues= function(bitwise) &#123; var trues = &apos;&apos;; if (this.num &gt;= 0) &#123; trues = (Array(bitwise).join(&quot;0&quot;) + this.binary_str).slice(-bitwise); &#125; if(this.num &lt; 0)&#123; trues = &apos;1&apos; + (Array(bitwise).join(&quot;0&quot;) + this.binary_str).slice(-(bitwise - 1)).replace(&apos;-&apos;,0); &#125; return trues;&#125;Binary.prototype.getOnes =function(bitwise) &#123; var ones = &apos;&apos;; if (this.num &gt;= 0) &#123; ones = (Array(bitwise).join(&quot;0&quot;) + this.binary_str).slice(-bitwise); &#125; if(this.num &lt;= 0)&#123; ones = &apos;1&apos; + (Array(bitwise).join(&quot;0&quot;) + this.binary_str).slice(-(bitwise - 1)).replace(&apos;-&apos;,0).split(&apos;&apos;).map(bit=&gt;bit==&apos;0&apos;?&apos;1&apos;:&apos;0&apos;).join(&apos;&apos;); &#125; return ones;&#125;Binary.prototype.getTwos =function(bitwise) &#123; var twos = &apos;&apos;, parse_ones_add_1 = parseInt(this.getOnes(bitwise), 2) + 1; if (this.num &gt;= 0) &#123; twos = (Array(bitwise).join(&quot;0&quot;) + this.binary_str).slice(-bitwise); &#125; if(this.num &lt;= 0)&#123; twos = &apos;1&apos;+(Array(bitwise).join(&quot;0&quot;) + parse_ones_add_1.toString(2)).slice(-(bitwise - 1)).replace(&apos;-&apos;,0); &#125; return twos;&#125;Binary.prototype.toString = function(bitwise = 32) &#123; var str = ` ====== 真值: $&#123;this.binary_str&#125;; 原码: $&#123;this.getTrues(bitwise)&#125;; 反码：$&#123;this.getOnes(bitwise)&#125;; 补码：$&#123;this.getTwos(bitwise)&#125;; ====== `; return str;&#125;Binary.prototype.valueOf = function() &#123; return parseInt(this.num, 10);&#125;Binary.format = function(str = &apos;&apos;, length = 4, replaceStr = &apos; &apos;) &#123; var reg = new RegExp(`(\\d)(?=(\\d&#123;$&#123;length&#125;&#125;)+(?!\\d))`, &apos;gi&apos;); return str.replace(reg, `$&amp;$&#123;replaceStr&#125;`);&#125;var a = new Binary(+new Binary(-11123));var format = Binary.format;console.log(a.toString(32));console.log(format(a.getTrues(32)));console.log(format(a.getOnes(32)));console.log(format(a.getTwos(32))); 在线实例：实现二进制类 位操作符概述按位操作符（Bitwise operators） 将其操作数（operands）当作32位的比特序列（由0和1组成），而不是十进制、十六进制或八进制数值。例如，十进制数9，用二进制表示则为1001。按位操作符操作数字的二进制形式，但是返回值依然是标准的JavaScript数值。 运算符 用法 描述 按位与（ AND） a &amp; b 对于每一个比特位，只有两个操作数相应的比特位都是1时，结果才为1，否则为0。 按位或（OR） a &#124; b 对于每一个比特位，当两个操作数相应的比特位至少有一个1时，结果为1，否则为0。 按位异或（XOR） a ^ b 对于每一个比特位，当两个操作数相应的比特位有且只有一个1时，结果为1，否则为0。 按位非（NOT） ~a 反转操作数的比特位，即0变成1，1变成0。 左移（Left shift） a &lt;&lt; b 将 a 的二进制形式向左移 b (&lt; 32) 比特位，右边用0填充。 有符号右移 a &gt;&gt; b 将 a 的二进制表示向右移 b (&lt; 32) 位，丢弃被移出的位。 无符号右移 a &gt;&gt;&gt; b 将 a 的二进制表示向右移 b (&lt; 32) 位，丢弃被移出的位，并使用 0 在左侧填充。 有符号32位整数所有的按位操作符的操作数都会被转成补码（two’s complement）形式的有符号32位整数。补码形式是指一个数的负对应值（negative counterpart）（如 5和-5）为数值的所有比特位反转后，再加1。反转比特位即该数值进行’非‘位运算，也即该数值的反码。 按位逻辑操作符从概念上讲，按位逻辑操作符按遵守下面规则： 操作数被转换成32位整数，用比特序列（0和1组成）表示。超过32位的数字会被丢弃。例如, 以下具有32位以上的整数将转换为32位整数。 第一个操作数的每个比特位与第二个操作数的相应比特位匹配：第一位对应第一位，第二位对应第二位，以此类推。 位运算符应用到每对比特位，结果是新的比特值。 123456789101112131415161718192021222324252627function logOperate(a, b, op) &#123; var ba = new Binary(a), bb = new Binary(b), format = Binary.format, opList = &#123; &apos;&amp;&apos;: (a, b) =&gt; a &amp; b, &apos;|&apos;: (a, b) =&gt; a | b, &apos;^&apos;: (a, b) =&gt; a ^ b, &apos;~&apos;: a =&gt; ~a, &apos;&lt;&lt;&apos;: (a, b) =&gt; a &lt;&lt; b, &apos;&gt;&gt;&apos;: (a, b) =&gt; a &gt;&gt; b, &apos;&gt;&gt;&gt;&apos;: (a, b) =&gt; a &gt;&gt; b, &#125;, bop = new Binary(opList[op](a, b));// console.log(format(ba.getTrues(32)));// console.log(format(bb.getTrues(32)));// console.log(format(bop.getTrues(32)));// console.log(format(ba.getOnes(32)));// console.log(format(bb.getOnes(32)));// console.log(format(bop.getOnes(32))); console.log(format(ba.getTwos(32))); console.log(format(bb.getTwos(32))); console.log(format(bop.getTwos(32))); &#125; &amp; (按位与)对每对比特位执行与（AND）操作。只有 a 和 b 都是 1 时，a AND b 才是 1。与操作的真值表如下: a b a&amp;b 0 0 0 0 1 0 1 0 0 1 1 1 将任一数值 x 与 0 执行按位与操作，其结果都为 0。将任一数值 x 与 -1 执行按位与操作，其结果都为 x。 123456789logOperate(2, 3, &apos;&amp;&apos;);// 0000 0000 0000 0000 0000 0000 0000 0010// 0000 0000 0000 0000 0000 0000 0000 0011// 0000 0000 0000 0000 0000 0000 0000 0010logOperate(-2, -3, &apos;&amp;&apos;);// 1111 1111 1111 1111 1111 1111 1111 1110// 1111 1111 1111 1111 1111 1111 1111 1101// 1111 1111 1111 1111 1111 1111 1111 1100 | (按位或)对每一对比特位执行或（OR）操作。如果 a 或 b 为 1，则 a OR b 结果为 1。或操作的真值表： a b a &#124; b 0 0 0 0 1 1 1 0 1 1 1 1 将任一数值 x 与 0 进行按位或操作，其结果都是 x。将任一数值 x 与 -1 进行按位或操作，其结果都为 -1。 123456789logOperate(2, 3, &apos;|&apos;);// 0000 0000 0000 0000 0000 0000 0000 0010// 0000 0000 0000 0000 0000 0000 0000 0011// 0000 0000 0000 0000 0000 0000 0000 0011logOperate(-2, -3, &apos;|&apos;);// 1111 1111 1111 1111 1111 1111 1111 1110// 1111 1111 1111 1111 1111 1111 1111 1101// 1111 1111 1111 1111 1111 1111 1111 1111 123456789101112131415161718192021222324251 | 0 ; // 11.1 | 0 ; // 1&apos;asfdasfda&apos; | 0 ; // 00 | 0 ; // 0(-1) | 0 ; // -1(-1.5646) | 0 ; // -1[] | 0 ; // 0(&#123;&#125;) | 0 ; // 0&quot;123456&quot; | 0 ; // 1234561.23E2 | 0; // 1231.23E12 | 0; // 1639353344-1.23E2 | 0; // -123-1.23E12 | 0; // -1639353344 ^ (按位异或)对每一对比特位执行异或（XOR）操作。当 a 和 b 不相同时，a XOR b 的结果为 1。异或操作真值表： a b a ^ b 0 0 0 0 1 1 1 0 1 1 1 0 123456789logOperate(2, 3, &apos;^&apos;);// 0000 0000 0000 0000 0000 0000 0000 0010// 0000 0000 0000 0000 0000 0000 0000 0011// 0000 0000 0000 0000 0000 0000 0000 0001logOperate(-2, -3, &apos;^&apos;);// 1111 1111 1111 1111 1111 1111 1111 1110// 1111 1111 1111 1111 1111 1111 1111 1101// 0000 0000 0000 0000 0000 0000 0000 0011 将任一数值 x 与 0 进行异或操作，其结果为 x。将任一数值 x 与 -1 进行异或操作，其结果为 ~x。 ~ (按位非)对每一个比特位执行非（NOT）操作。NOT a 结果为 a 的反转（即反码）。非操作的真值表： a ~a 0 1 1 1 对任一数值 x 进行按位非操作的结果为 -(x + 1)。例如，~5 结果为 -6。 123456789101112// 判断字符串是否存在：// eg: var str = &apos;heaven is a place nearby!&apos;;var search = &apos;a&apos;;// str.indexOf(search) &gt;= 0// -str.indexOf(search) &lt;= 0// ~str.indexOf(search)logOperate(2, 0, &apos;~&apos;);// 0000 0000 0000 0000 0000 0000 0000 0010// 1111 1111 1111 1111 1111 1111 1111 1101 按位移动操作符按位移动操作符有两个操作数：第一个是要被移动的数字，而第二个是要移动的长度。移动的方向根据操作符的不同而不同。 按位移动会先将操作数转换为大端字节序顺序(big-endian order)的32位整数,并返回与左操作数相同类型的结果。右操作数应小于 32位，否则只有最低 5 个字节会被使用。 123456注：Big-Endian:高位字节排放在内存的低地址端，低位字节排放在内存的高地址端，又称为&quot;高位编址&quot;。Big-Endian是最直观的字节序：①把内存地址从左到右按照由低到高的顺序写出；②把值按照通常的高位到低位的顺序写出；③两者对照，一个字节一个字节的填充进去。 &lt;&lt; (左移)该操作符会将第一个操作数向左移动指定的位数。向左被移出的位被丢弃，右侧用 0 补充。 在数字 x 上左移 y 比特得到 x * 2y. 1234567logOperate(2, 3, &apos;~&apos;); // 16// 0000 0000 0000 0000 0000 0000 0000 0010// 0000 0000 0000 0000 0000 0000 0001 0000logOperate(-2, 3, &apos;~&apos;); // -16// 1111 1111 1111 1111 1111 1111 1111 1110// 1111 1111 1111 1111 1111 1111 1111 0000 &gt;&gt; (有符号右移)该操作符会将第一个操作数向右移动指定的位数。向右被移出的位被丢弃，拷贝最左侧的位以填充左侧。由于新的最左侧的位总是和以前相同，符号位没有被改变。所以被称作“符号传播”。 1234567logOperate(8, 3, &apos;&gt;&gt;&apos;);// 0000 0000 0000 0000 0000 0000 0000 1000// 0000 0000 0000 0000 0000 0000 0000 0001logOperate(-5, 4, &apos;&gt;&gt;&apos;);// 1111 1111 1111 1111 1111 1111 1111 1011// 1111 1111 1111 1111 1111 1111 1111 1111 &gt;&gt;&gt; (无符号右移)该操作符会将第一个操作数向右移动指定的位数。向右被移出的位被丢弃，左侧用0填充。因为符号位变成了 0，所以结果总是非负的。（译注：即便右移 0 个比特，结果也是非负的。） 对于非负数，有符号右移和无符号右移总是返回相同的结果。 1234567logOperate(8, 3, &apos;&gt;&gt;&gt;&apos;);// 0000 0000 0000 0000 0000 0000 0000 1000// 0000 0000 0000 0000 0000 0000 0000 0001logOperate(-8, 3, &apos;&gt;&gt;&gt;&apos;);// 1111 1111 1111 1111 1111 1111 1111 1000// 1111 1111 1111 1111 1111 1111 1111 1111 位操作符代码实例 掩码位运算经常被用来创建、处理以及读取标志位序列——一种类似二进制的变量。虽然可以使用变量代替标志位序列，但是这样可以节省内存（1/32）。 掩码 (bitmask) 是一个通过与/或来读取标志位的位序列。典型的定义每个标志位的原语掩码如下，例如，有四个标志位：A,B,C,D 1234var FLAG_A = 1; // 0001var FLAG_B = 2; // 0010var FLAG_C = 4; // 0100var FLAG_D = 8; // 1000 新的掩码可以在以上掩码上使用逻辑运算创建。例如，掩码 1011 可以通过 FLAG_A、FLAG_B 和 FLAG_D 逻辑或得到： 1var mask = FLAG_A | FLAG_B | FLAG_D; // 0001 | 0010 | 1000 =&gt; 1011 某个特定的位可以通过与掩码做逻辑与运算得到，通过与掩码的与运算可以去掉无关的位，得到特定的位。例如，掩码 0100 可以用来检查标志位 C 是否被置位： 1234// 判断是否含有FLAG_Cif (flags &amp; FLAG_C) &#123; // 0101 &amp; 0100 =&gt; 0100 =&gt; true // do stuff&#125; 一个有多个位被置位的掩码表达任一/或者的含义。例如，以下两个表达是等价的： 123456789101112// 如果我们有 FLAG_B 或者 FLAG_C 至少一个// (0101 &amp; 0010) || (0101 &amp; 0100) =&gt; 0000 || 0100 =&gt; trueif ((flags &amp; FLAG_B) || (flags &amp; FLAG_C)) &#123; // do stuff&#125;// 等价于var mask = FLAG_B | FLAG_C; // 0010 | 0100 =&gt; 0110if (flags &amp; mask) &#123; // 0101 &amp; 0110 =&gt; 0100 =&gt; true // do stuff&#125; 可以通过与掩码做或运算设置标志位，掩码中为 1 的位可以设置对应的位。例如掩码 1100 可用来设置位 C 和 D： 12var mask = FLAG_C | FLAG_D; // 0100 | 1000 =&gt; 1100flags |= mask; // 0101 | 1100 =&gt; 1101 可以通过与掩码做与运算清除标志位，掩码中为 0 的位可以设置对应的位。掩码可以通过对原语掩码做非运算得到。例如，掩码 1010 可以用来清除标志位 A 和 C ： 12var mask = ~(FLAG_A | FLAG_C); // ~0101 =&gt; 1010flags &amp;= mask; // 1101 &amp; 1010 =&gt; 1000 如上的掩码同样可以通过 ~FLAG_A &amp; ~FLAG_C 得到（德摩根定律）： 12var mask = ~FLAG_A &amp; ~FLAG_C;flags &amp;= mask; // 1101 &amp; 1010 =&gt; 1000 标志位可以使用异或运算切换。所有值为 1 的为可以切换对应的位。例如，掩码 0110 可以用来切换标志位 B 和 C： 12var mask = FLAG_B | FLAG_C;flags = flags ^ mask; // 1100 ^ 0110 =&gt; 1010 最后，所有标志位可以通过非运算翻转: 12// entering parallel universe...flags = ~flags; // ~1010 =&gt; 0101 位操作使用实例1.判断一个数a的奇偶：12345// 奇数a &amp; 1 === 1;// 偶数a &amp; 1 === 0; 2.两个整数x,y的平均值：1const avarage = (x, y) =&gt; (x &amp; y) + ((x ^ y) &gt;&gt; 1); 3.不使用缓存交换两个整数：1234567891011121314151617// 正常版本var swap1 = (x, y) =&gt; &#123; if (x !== y ) &#123; var z = x; x = y; y = z; &#125;&#125;// 使用位操作符var swap = (x, y) =&gt; &#123; if (x !== y ) &#123; x ^= y; y ^= x; x ^= y; &#125;&#125; 4.老鼠试毒：假设有1000杯水，其中有一杯有毒，至少用多少只老鼠试出哪杯有毒? 123456789101112131415161718192021222324252627282930// 使用位掩码解决// 假设共有8杯水，标记：var cup_a = 1; // 0001var cup_b = 2; // 0010var cup_c = 3; // 0011var cup_d = 4; // 0100var cup_e = 5; // 0101var cup_f = 6; // 0110var cup_g = 7; // 0111var cup_h = 8; // 1000// 转置矩阵可得：0000 00010001 11100110 01101010 10101234 5678// mouse_a = 8;mouse_b = 4 | 5 | 6 | 7;mouse_c = 2 | 3 | 6 | 7;mouse_d = 1 | 3 | 5 | 7;2^4 = 8;....2^10 = 1024也就是：0000000001，0000000010，0000000011，...，1111101000；道理同上。 5.权限问题：在实际开发中，我们常常遇到权限的判断的问题，比如说，不同的用户对系统有不同的操作权限，有的用户可能有多种权限，我们最常规的办法就是每一个权限定义一个BOOL值。假设，某系统有4种权限，那么，就有了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// var role = &#123;// a: &apos;a&apos;,// b: &apos;b&apos;,// c: &apos;c&apos;,// c: &apos;d&apos;,// &#125;;// 判断某用户有三种权限： role.a &amp;&amp; role.b &amp;&amp; role.c// 使用位操作：// var role = &#123;// a: 1 &lt;&lt; 0, // 0001// b: 1 &lt;&lt; 1, // 0010// c: 1 &lt;&lt; 2, // 0100// d: 1 &lt;&lt; 3, // 1000// &#125;// 判断某用户有三种权限： role.a | role.b | role.cvar role = &#123; a: 1 &lt;&lt; 0, // 0001 b: 1 &lt;&lt; 1, // 0010 c: 1 &lt;&lt; 2, // 0100 d: 1 &lt;&lt; 3, // 1000&#125;function Permission(flag)&#123; this.flag = flag;&#125;// 设置权限Permission.prototype.set = function(perm) &#123; this.flag = perm;&#125;// 添加一项或多项权限Permission.prototype.enable = function(perm) &#123; this.flag |= perm;&#125;// 删除一项或多项权限Permission.prototype.disable = function(perm) &#123; this.flag &amp;= ~perm;&#125;// 是否拥有某些权限Permission.prototype.has = function(perm) &#123; return (this.flag &amp; perm) === perm;&#125;// 是否禁用了某些权限Permission.prototype.not = function(prem) &#123; return (this.flag &amp; perm) === 0;&#125;// 是否仅仅拥有某些权限Permission.prototype.only = function(perm) &#123; return this.flag === perm;&#125;// 打印当前权限Permission.prototype.log = function() &#123; var perm_list_key = []; Object.keys(role).forEach(key =&gt; &#123; if(this.has(role[key]))&#123; perm_list_key.push(key); &#125; &#125;); console.log(&apos;当前权限:&apos;,perm_list_key.join(&apos;,&apos;)); return perm_list_key;&#125;var perm_a = new Permission(role.a | role.b | role.c);// perm_a.disable(role.a);console.log(perm_a); 通过位操作实现一个权限类]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JS-React-Redux+Dva」前端项目实践总结]]></title>
    <url>%2FBlog%2F2018%2F12%2F27%2FfrontEndPractice%2F</url>
    <content type="text"><![CDATA[No.1 网页布局基础学习，实现静态聊天网页 任务1：使用HTML+CSS+JS完成一个本地聊天Demo（模仿JTalk-PC），达到输入文本信息后，展示带有样式的内容。 涉及内容： 认识HTML标签 学习css属性，了解css与html相互作用基础 了解网页骨架结构的搭建，学习骨架的搭建，组件的划分 认识javascript语法、函数、变量、数据类型、作用域、事件、运算符、字符串、调试、闭包、代码规范 了解flex布局方案，学习弹性布局的作用 布局调试工具的学习使用 重点： - Html元素类型：块级元素、内联元素(又叫行内元素)、内联块级元素。针对问题：开始时使用float浮动布局，因为这个方法破坏了文档流造成高度塌陷，出现多处定位问题，后仔细了解行内块级元素布局方法，完成页面布局。 内联元素（行内）：display：inline；/、、、、、、1、和其他元素都在一行上；2、元素的高度、宽度及顶部和底部边距不可设置；3、元素的宽度就是它包含的文字或图片的宽度，不可改变。 块级（独占一行）：display：block；/、、…、、、、、、 、1、每个块级元素都从新的一行开始，并且其后的元素也另起一行。（霸道，一个块级元素独占一行）2、元素的高度、宽度、行高以及顶和底边距都可设置。3、元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致） 行内块：display：inline-block；float:left / right；position：absolute/fixed;、1、和其他元素都在一行上；2、元素的高度、宽度、行高以及顶和底边距都可设置 - Flexbox 弹性布局针对问题：寻找将整个Div内容居中在屏幕中心的办法 No.2 React学习，使用React框架重构前期内容任务2：使用React重构完成Demo2，将网页组件化，并完成前端与服务器间的数据操作，做到用户输入消息，请求到服务器，并从服务器返回此消息作为回复。 涉及内容： 学习异步编程ajax、Promise、fetch、setTimeout、setInterval 根据之前的静态页面，实现静态页面的前端功能 认识React框架基础，掌握React生命周期，以及基本代码API React：//学习参考https://segmentfault.com/a/1190000012921279#articleHeader18 React是一个用来构建UI的JS库，满足前端组件化开发模式。 babel编译器和webpack打包工具封装在creat-react-app的脚手架中。 通过 JS函数 创建无状态组件，通过 class 创建有状态组件，以此将「单纯展示数据」的组件和「有业务逻辑、需要操作数据」的组件分离 重点： - React的生命周期组件的生命周期是从创建到挂载再到卸载的一个完整周期。这三个阶段总是伴随着组件各种各样的事件，这些事件被统称为组件的生命周期函数。 - 异步编程Javascript语言的执行环境是”单线程”，使用异步模式避免耗时长的操作造成浏览器失去响应。在Demo2中使用了Ajax操作。 AJAX：是一种在无需重新加载整个网页的情况之下能够更新部分网页的技术。GET - 从指定的资源请求数据POST - 向指定的资源提交要处理的数据 使用Ajax请求一个 JSON 数据一般是这样：123456789101112131415161718192021//创建XHR对象var xhr = new XMLHttpRequest();//规定请求的类型、URL 以及是否异步处理请求xhr.open(&apos;GET&apos;, url/file,true);//规定当服务器响应已做好被处理的准备时所执行的任务xhr.onreadystatechange = function() &#123; if(xhr.readyState==4)&#123; if(xhr.status==200)&#123; //获得字符串形式的响应数据。 var data=xhr.responseText; console.log(data); &#125;&#125;;xhr.onerror = function() &#123; console.log(&quot;Oh, error&quot;);&#125;;//将请求发送到服务器xhr.send(); 使用fetch请求JSON数据：12345678//解析为可读数据fetch(url).then(response =&gt; response.json()) //执行结果是 resolve就调用then方法 .then(data =&gt; console.log(data)) //执行结果是 reject就调用catch方法 .catch(err =&gt; console.log(&quot;Oh, error&quot;, err)) Fetch：语法简洁，更加语义化； 基于标准 Promise 实现。 Promise： fetch方法返回一个Promise对象, 根据 Promise Api 的特性, fetch可以方便地使用then方法将各个处理逻辑串起来, 使用 Promise.resolve() 或 Promise.reject() 方法将分别返会肯定结果的Promise或否定结果的Promise, 从而调用下一个then 或者 catch，catch用来指定reject的回调。 No.3 Redux、Dva学习，将Demo移植到项目中任务3：使用Dva完成Demo3，掌握一次开发的完整过程，在Demo3中完成发送一条消息，能够获取服务器的数据并进行回复展示。 涉及内容： 学习异步编程ajax、Promise、fetch、setTimeout、setInterval 根据之前的静态页面，实现静态页面的前端功能 认识React框架基础，掌握React生命周期，以及基本代码API 理解Redux概念和Dva概念 Redux：Redux 是 JavaScript 状态容器，在react项目中，搭配redux数据流开发，将UI层和数据层区分开。惟一改变 state 的办法是触发 action，通过编写 reducers 来描述 action 如何改变 state 。 对于没有父子关系的组件需要进行通信的情况，redux在组件树中使用store容器，令组件dispatch状态更改到store中。store中包含的就是更新state的reducers，使得所有的状态更改都通过单一store进行。容器组件使用 React Redux 的 connect() 方法来生成。 而Dva在redux数据流方案上，简化了开发体验，额外内置了 react-router 和 fetch。Dva 通过 model 的概念把一个领域的模型管理起来，包含同步更新 state 的 reducers，处理异步逻辑的 effects，订阅数据源的 subscriptions 。]]></content>
      <categories>
        <category>front end practice</category>
      </categories>
      <tags>
        <tag>前端练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成器基础和扩展]]></title>
    <url>%2FBlog%2F2018%2F11%2F11%2Fgenerator%2F</url>
    <content type="text"><![CDATA[生成器基础和扩展 可迭代协议和迭代器协议可迭代协议可迭代协议允许 JavaScript 对象去定义或定制它们的迭代行为, 例如（定义）在一个 for..of 结构中什么值可以被循环（得到）。一些内置类型都是内置的可迭代对象并且有默认的迭代行为, 比如 Array or Map, 另一些类型则不是 (比如Object) 。 为了变成可迭代对象， 一个对象必须实现 @@iterator 方法, 意思是这个对象（或者它原型链 prototype chain 上的某个对象）必须有一个名字是 Symbol.iterator 的属性: 属性 值 [Symbol.iterator] 返回一个对象的无参函数，被返回对象符合迭代器协议。 当一个对象需要被迭代的时候（比如开始用于一个for..of循环中），它的@@iterator方法被调用并且无参数，然后返回一个用于在迭代中获得值的迭代器。 迭代器协议该迭代器协议定义了一种标准的方式来产生一个有限或无限序列的值。 当一个对象被认为是一个迭代器时，它实现了一个 next() 的方法并且拥有以下含义： 属性: next 值：返回一个对象的无参函数，被返回对象拥有两个属性： done (boolean) 如果迭代器已经经过了被迭代序列时为 true。这时 value 可能描述了该迭代器的返回值。返回值在这里有更多解释。 如果迭代器可以产生序列中的下一个值，则为 false。这等效于连同 done 属性也不指定。 value - 迭代器返回的任何 JavaScript 值。done 为 true 时可省略。 迭代器它是一种接口，为各种不同的数据结构提供统一的访问机制。 Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of消费。 ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。该迭代器可以被 for…of 循环使用。 原生具备 Iterator 接口的数据结构如下： Array Map Set String TypedArray 函数的 arguments 对象 NodeList 对象 创建自定义迭代器1234567891011var myIterable = &#123; *[Symbol.iterator] ()&#123; yield 1; yield 2; yield 3; &#125;&#125;console.log([...myIterable]);for(let i of myIterable)&#123; console.log(i);&#125; Symbol.iterator迭代器代码示例 使用场合 结构赋值： 对数组和 Set 结构进行解构赋值时，会默认调用Symbol.iterator方法。 1234567let set = new Set().add(&apos;a&apos;).add(&apos;b&apos;).add(&apos;c&apos;);let [x,y] = set;// x=&apos;a&apos;; y=&apos;b&apos;let [first, ...rest] = set;// first=&apos;a&apos;; rest=[&apos;b&apos;,&apos;c&apos;]; spread运算符（…）： spread运算符（…）也会调用默认的 Iterator 接口。 12345678// 例一var str = &apos;hello&apos;;[...str] // [&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;]// 例二let arr = [&apos;b&apos;, &apos;c&apos;];[&apos;a&apos;, ...arr, &apos;d&apos;]// [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;] yield* 1234567891011121314let generator = function* () &#123; yield 1; yield* [2,3,4]; yield 5;&#125;;var iterator = generator();iterator.next() // &#123; value: 1, done: false &#125;iterator.next() // &#123; value: 2, done: false &#125;iterator.next() // &#123; value: 3, done: false &#125;iterator.next() // &#123; value: 4, done: false &#125;iterator.next() // &#123; value: 5, done: false &#125;iterator.next() // &#123; value: undefined, done: true &#125; 其他场合 for…of Array.from() Map(), Set(), WeakMap(), WeakSet()（比如new Map([[‘a’,1],[‘b’,2]])） Promise.all() Promise.race() 生成器生成器对象是由一个 generator function 返回的,并且它符合可迭代协议和迭代器协议。 语法12345678function *gen() &#123; yield 1; yield 2; yield 3;&#125;let g = gen(); // &quot;Generator &#123; &#125;&quot; 方法 Generator.prototype.next()：返回一个由 yield表达式生成的值。 Generator.prototype.return()：返回给定的值并结束生成器。 Generator.prototype.throw()： 向生成器抛出一个错误。 next()next() 方法返回一个包含属性 done 和 value 的对象。该方法也可以通过接受一个参数用以向生成器传值。 1gen.next(value) 参数value: 向生成器传递的值。 返回值： done(Boolean): 当迭代器遍历到迭代序列末端时返回值 true。此时，迭代器可以将返回值作为 value。 当迭代器仍可继续在迭代序列中向前遍历时返回值 false。这相当于不指定 done 属性。 value: 迭代器返回的任意的Javascript值。当 done 的值为 true 时可以忽略该值。 return()return() 方法返回给定的值并结束生成器。 1gen.return(value) value: 需要返回的值 返回值：{ value, done: true } throw()throw() 方法用来向生成器抛出异常，并恢复生成器的执行，返回带有 done 及 value 两个属性的对象。 1gen.throw(exception) exception：用于抛出的异常 返回值： done (boolean)： 如果迭代器已经返回了迭代序列的末尾，则值为 true。在这种情况下，可以指定迭代器 value 的返回值。 如果迭代能够继续生产在序列中的下一个值，则值为 false。 这相当与不指定 done 属性的值。 value - 迭代器返回的任何 JavaScript 值。当 done 是 true 的时候可以省略。 生成器函数function* 这种声明方式(function关键字后跟一个星号）会定义一个生成器函数 (generator function)，它返回一个 Generator 对象。 语法12345678910111213141516function *name([param[, param[, ... param]]]) &#123; statements &#125;或者new GeneratorFunction ([arg1[, arg2[, ...argN]],] functionBody)// arg1, arg2, ... argN: 参数 // 函数使用的名称作为形式参数名称。// 每个必须是一个字符串，// 对应于一个有效的JavaScript标识符或这样的字符串的列表，// 用逗号分隔；如“x”，“theValue”或“a,b”。// functionBody: 一个包含多条表示JavaScript函数体语句的字符串// 注意：GeneratorFunction并不是一个全局对象，通过：// Object.getPrototypeOf(function*()&#123;&#125;).constructor获取 描述 生成器函数在执行时能暂停，后面又能从暂停处继续执行。 调用一个生成器函数并不会马上执行它里面的语句，而是返回一个这个生成器的迭代器（iterator）对象。 当这个迭代器的 next()方法被首次（后续）调用时，其内的语句会执行到第一个（后续）出现yield的位置为止，yield 后紧跟迭代器要返回的值。或者如果用的是 yield*（多了个星号），则表示将执行权移交给另一个生成器函数（当前生成器暂停执行） next()方法返回一个对象，这个对象包含两个属性：value 和 done，value 属性表示本次 yield 表达式的返回值，done 属性为布尔类型，表示生成器后续是否还有 yield 语句，即生成器函数是否已经执行完毕并返回 调用 next()方法时，如果传入了参数，那么这个参数会作为上一条执行的 yield 语句的返回值 generator 声明方式 生成器委托yield* 表达式用于委托给另一个generator 或可迭代对象 语法1yield* [[expression]]; expression： 返回一个可迭代对象的表达式。 描述 yield* 表达式迭代操作数，并产生它返回的每个值。 yield* 表达式本身的值是当迭代器关闭时返回的值（即done为true时）。 生成器委托 生成器委托传入值 生成器委托中含return 生成器委托throw 高级用法1.生成器的传入值与传出值12345678910function *foo(x) &#123; var y = 2 * (yield (x + 1)); var z = yield (y / 3); return (x + y + z);&#125;var it = foo( 5 );console.log( it.next() ); // &#123; value:6, done:false &#125;console.log( it.next( 12 ) ); // &#123; value:8, done:false &#125;console.log( it.next( 13 ) ); // &#123; value:42, done:true &#125; 2.错误处理123456789101112function *foo(x)&#123; try&#123; var a = yield x; console.log(&apos;a:&apos;, a); &#125; catch(e) &#123; console.log(&apos;err&apos;, e); &#125;&#125;var gen = foo(3);gen.next();gen.throw(&apos;ops!&apos;); 生成器的传入值与传出值 3.生成器自执行器1234567891011121314151617181920function run(genFuc, initialValue) &#123; const gen = genFuc(initialValue); iterate(gen); function iterate(gen) &#123; step(); function step(arg, isError) &#123; const &#123;value: express, done&#125; = isError ? gen.throw(arg) : gen.next(arg); let response; if (!done) &#123; if (typeof express === &apos;function&apos;) &#123; response = express(); &#125; else &#123; response = express; &#125; Promise.resolve(response).then(step, err =&gt; step(err, true)); &#125; &#125; &#125;&#125; 4.遍历一棵二叉树1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Btree&#123; constructor(value, left=null, right=null) &#123; this.value = value; this.left = left; this.right = right; &#125; /** 默认先序 */ * [Symbol.iterator]() &#123; yield this.value; if (this.left) &#123; yield* this.left; &#125; if (this.right) &#123; yield* this.right; &#125; &#125; /** 先序遍历 */ *preOrder() &#123; yield console.log(this.value); if (this.left) &#123; yield *this.left.preOrder(); &#125; if (this.right) &#123; yield *this.right.preOrder(); &#125; &#125; /** 中序遍历 */ *inOrder() &#123; if(this.left)&#123; yield *this.left.inOrder(); &#125; yield console.log(this.value); if(this.right)&#123; yield *this.right.inOrder(); &#125; &#125; /** 后序遍历 */ *postOrder() &#123; if(this.left)&#123; yield *this.left.postOrder(); &#125; if(this.right)&#123; yield *this.right.postOrder(); &#125; yield console.log(this.value); &#125;&#125;let tree = new Btree(&apos;a&apos;, new Btree(&apos;b&apos;, new Btree(&apos;c&apos;), new Btree(&apos;d&apos;)), new Btree(&apos;e&apos;));for (let x of tree) &#123; console.log(x);&#125;// Output: a,b,c,d,e generator实现一棵二叉树的先中后序遍历 5.生成器的并发生成器的并发 async 函数async function是什么？其实就是generator的语法糖，即generator + 自动执行器。 async function对Generator 函数的改进，体现在： 内置执行器 更好的语义： async 和 await语法 返回值是Promise 语法12345678910async function name([param[, param[, ... param]]]) &#123; statements &#125;或者var name = async () =&gt; &#123;&#125;或者var AsyncFunction= Object.getPrototypeOf(async function()&#123;&#125;).constructor;var asyncInstance = new AsyncFunction([arg1[, arg2[, ...argN]],] functionBody)； 错误处理将async 函数内部的await语句用try…catch结构包裹. 123456789101112async f()&#123; try &#123; await f1(); await f2(); .... &#125; catch(err) &#123;// console.log(err);// 或者// return Promise.reject(err);// 再通过返回的Promise结果的catch方法捕获异常。 &#125;&#125; *异步迭代器异步迭代器的next()方法返回一个{ value, done } 的 promise。 12345678910111213 const asyncIter = &#123;- [Symbol.iterator]: () =&gt; &#123;+ [Symbol.asyncIterator]: () =&gt; &#123; const items = [&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;]; return &#123;- next: () =&gt; (&#123;+ next: () =&gt; Promise.resolve(&#123; done: items.length === 0, value: items.shift() &#125;) &#125; &#125; &#125; for await..of 用来遍历异步的 Iterator 接口。 ==for-await-of 只能在 async 函数或者 async 生成器里面使用==。 异步遍历器]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>生成器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iconFont]]></title>
    <url>%2FBlog%2F2018%2F10%2F17%2FiconFont%2F</url>
    <content type="text"><![CDATA[1.原理1.1 系统字体计算机中，各种信息都是以二进制编码的形式存在的，不管是文字还是其它各种信息，在计算机中都是以０和１组成的二进制代码表示的，之所以能区别这些信息的不同，是因为它们采用的编码规则不同。英文字母用的是单字节的ASCII码，汉字采用的是双字节的汉字内码。 字符（英文，包括字母、数字、标点、运算符等）编码，国际通用的ASCII码； 汉字的编码 汉字内码； 汉字外码； 汉字字形码。 在计算机内表示汉字而统一的编码方式形成汉字编码叫内码（如国标码），内码是惟一的。为方便汉字输入而形成的汉字编码为输入码，属于汉字的外码，输入码因编码方式不同而不同，是多种多样的。为显示和打印输出汉字而形成的汉字编码为字形码，计算机通过汉字内码在字模库中找出汉字的字形码，实现其转换。 1.2 web字体css font-family 通过定义web上面文字的fontfamily,确定页面显示字体。 1234.font&#123; font-size: 16px; font-family: &apos;微软雅黑&apos;;&#125; 但是这种情况下只能用系统默认的一些字体，限制比较大。web前端工程师必须使用已在用户计算机上安装好的字体。 css3可以自定义字体，加载自己的字体，使用 @font-face 定义一个字体family： css @font-face 这是一个叫做CSS@规则，它允许网页开发者为其网页指定在线字体，通过这种作者自备字体的方式，@font-face可以消除对用户电脑字体的依赖。1234567891011@font-face &#123; [ font-family: &lt;family-name&gt;; ] || /* 必填。所指定的字体名字将会被用于font或font-family属性 */ [ src: &lt;src&gt;; ] || /* 必填。远程字体文件位置的URL或者用户计算机上的字体名称， 可以使用local语法通过名称指定用户的本地计算机上的字体( i.e. src: local(&apos;Arial&apos;); )。 如果找不到该字体，将会尝试其他来源，直到找到它。*/ [ unicode-range: &lt;unicode-range&gt;; ] || /* 可选。定义该字体支持Unicode字符的范围。默认值是&quot;ü+0-10 FFFF&quot;*/ [ font-weight: &lt;font-weight&gt;; ] || /* 可选。定义字体的粗细。默认值是&quot;正常&quot; */ [ font-style: &lt;font-style&gt;; ] /* 可选。定义该字体应该是怎样样式。默认值是&quot;正常&quot; */ [ font-variant: &lt;font-variant&gt;; ] || [ font-feature-settings: &lt;font-feature-settings&gt;; ] || [ font-variation-settings: &lt;font-variation-settings&gt;; ] || [ font-stretch: &lt;font-stretch&gt;; ] || /*可选。定义该字体应该如何被拉长。默认值是&quot;正常&quot;*/&#125; See the Pen MPQbKd by vivizhou0596 (@vivizhou0596) on CodePen. 使用示例 12345678910111213141516/* 定义字体 */@font-face &#123; font-family: &quot;iconfont&quot;; src: url(&apos;iconfont.eot?t=1538029788022&apos;); /* IE9*/ src: url(&apos;iconfont.eot?t=1538029788022#iefix&apos;) format(&apos;embedded-opentype&apos;), /* IE6-IE8 */ url(&apos;data:application/x-font-woff;charset=utf-8;base64,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&apos;) format(&apos;woff&apos;), url(&apos;iconfont.ttf?t=1538029788022&apos;) format(&apos;truetype&apos;), /* chrome, firefox, opera, Safari, Android, iOS 4.2+*/ url(&apos;iconfont.svg?t=1538029788022#iconfont&apos;) format(&apos;svg&apos;); /* iOS 4.1- */&#125;/* 使用字体 */.iconfont &#123; font-family:&quot;iconfont&quot; !important; font-size:16px; font-style:normal;&#125; *注释： Firefox、Chrome、Safari 以及 Opera 支持 .ttf (True Type Fonts) 和 .otf (OpenType Fonts) 类型的字体。 Internet Explorer 9+ 支持新的 @font-face 规则，但是仅支持 .eot 类型的字体 (Embedded OpenType)。 Internet Explorer 8 以及更早的版本不支持新的 @font-face 规则。 2.实践##2.1 创建项目，引用图标先在阿里巴巴矢量图形库创建一个项目，添加一些图标。然后帮项目下载下来。 解压缩阿里图标库下载的文件，生成目录结构如下的文件夹： 12345678910-fontIcon--demo_fontclass.html--demo_symbol.html--demo_unicode.html--iconfont.css--iconfont.eot--iconfont.js--iconfont.svg--iconfont.tty--iconfont.woff css、html、js文件，是关于使用的说明和demo； ttf、eot、woff、svg字体文件，最常用的ttf文件，另外三个是为了兼容不同的浏览器而额外引入的。 2.2 解析字体文件工具软件：FontForge按如下步骤操作，查看系统的calibri字体：1.打开控制面板-字体-找到calibri字体，将文件拷到新的文件夹中;2.使用FontoForge打开calibri文件，会看到如下一张表； 字体文件就是这样以unicode作为索引的字形表，双击里面的某个字形，可以对它进行编辑，每个字形其实就是一个矢量图，因此ttf文件所表示的字库也叫矢量字库； 与之对应的另一种字库——点阵字库，两者最大的区别就是点阵字库可以在Console Mode（命令行模式）下被渲染出来，而矢量字库必须在Graphics Mode（图形模式）中被渲染。 2.3 字体定义打开iconfont.css，可以看到 @font-face 声明，前文提到的自定义字体的声明，其中font-family属性定义了这个字体的名称，src属性定义了该要渲染字体需要下载的字体文件。 1234567@font-face &#123;font-family: &quot;iconfont&quot;; src: url(&apos;iconfont.eot?t=1537518751733&apos;); /* IE9*/ src: url(&apos;iconfont.eot?t=1537518751733#iefix&apos;) format(&apos;embedded-opentype&apos;), /* IE6-IE8 */ url(&apos;data:application/x-font-woff;charset=utf-8;base64,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&apos;) format(&apos;woff&apos;), url(&apos;iconfont.ttf?t=1537518751733&apos;) format(&apos;truetype&apos;), /* chrome, firefox, opera, Safari, Android, iOS 4.2+*/ url(&apos;iconfont.svg?t=1537518751733#iconfont&apos;) format(&apos;svg&apos;); /* iOS 4.1- */&#125; 为何有两个src？ 1绝大多数情况下，第一个 src 是可以去掉的，除非需要支持 IE9 下的兼容模式。在 IE9 中可以使用 IE7 和 IE8 的模式渲染页面，微软修改了在兼容模式下的 CSS 解析器，导致使用 ? 的方案失效。由于 CSS 解释器是从下往上解析的，所以在上面添加一个不带问号的 src 属性便可以解决此问题。 #iefix有何作用？1IE9 之前的版本没有按照标准解析字体声明，当 src 属性包含多个 url 时，它无法正确的解析而返回 404 错误，而其他浏览器会自动采用自己适用的 url。因此把仅 IE9 之前支持的 EOT 格式放在第一位，然后在 url 后加上 ?，这样 IE9 之前的版本会把问号之后的内容当作 url 的参数。至于 #iefix 的作用，一是起到了注释的作用，二是可以将 url 参数变为锚点，减少发送给服务器的字符。 后面的src和一堆url主要是为了兼容不同的浏览器，format属性告诉浏览器这个字体的格式，可选的字体格式有 woff、woff2、truetype、opentype、embedded-opentype、svg。 2.4 字体使用 阿里提供Unicode、Font-class、Symbol三种引用方式。 2.4.1 Unicode 1234567891011/* HTML */ &lt;i class=&quot;iconfont&quot;&gt;&amp;#xe626;&lt;/i&gt;/* css */ .iconfont &#123; font-family:&quot;iconfont&quot; !important; font-size:16px; font-style:normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; &#125; html中’&#xe626;’其中&amp;表示转义，#x可以用于表示16进制转义字符（Unicode主流的规范是UCS-2，即3个字节表示一个字符，所以unicode字符可以用一个16进制数表示）。 事实上，你也可以用“&amp;#”对10进制的数进行转义，比如0xe626用十进制表示为58918，在html中你就可以这么写：1&lt;i class=&quot;icon testfont&quot;&gt;&amp;#58918;&lt;/i&gt; 我们可以直接从下载的demo_unicode.html文件中找到该图标对应的16进制数；如果你想对这个图形做一些修改，可以用fontForge打开字体文件，接着根据16进制数或者图标名字来定位到该图标：当在你在FontForge中修改了字形后，点击File-&gt;Generage Fonts.. 生成字体文件（记住每种格式导出一份），然后在font-face中修改文件的引用地址即可。 2.4.2 Font-class这种引入方式和原理第一种类似 12345/* html */ &lt;i class=&quot;iconfont icon-guanbi&quot;&gt;&lt;/i&gt;/* css */ .icon-guanbi:before &#123; content: &quot;\e626&quot;; &#125; 这种方式只是在原来的dom上增加一个伪元素，css中正斜杠\表示一个16进制数字。这样写的好处是可以直接通过审查dom元素就知道它引用的是哪个字形，看起来更加语义化。 2.4.3 Symbol iconfont事实上使用的是使用系统字体渲染引擎，而它是只支持单色的。 官网称Symbol可以实现多色，如何做到的呢？以下是官网对其的描述：123456这是一种全新的使用方式，应该说这才是未来的主流，也是平台目前推荐的用法。这种用法其实是做了一个svg的集合，与另外两种相比具有如下特点：- 支持多色图标了，不再受单色限制。- 通过一些技巧，支持像字体那样，通过font-size,color来调整样式。- 兼容性较差，支持 ie9+,及现代浏览器。- 浏览器渲染svg的性能一般，还不如png。 使用步骤如下： 第一步：引入项目下面生成的symbol代码：1&lt;script src=&quot;./iconfont.js&quot;&gt;&lt;/script&gt; 第二步：加入通用css代码（引入一次就行）：12345678910111213&lt;style type=&quot;text/css&quot;&gt; .icon &#123; /* 通过设置 font-size 来改变图标大小 */ width: 1em; height: 1em; /* 图标和文字相邻时，垂直对齐 */ vertical-align: -0.15em; /* 通过设置 color 来改变 SVG 的颜色/fill */ fill: currentColor; /* path 和 stroke 溢出 viewBox 部分在 IE 下会显示 normalize.css 中也包含这行 */ overflow: hidden; &#125;&lt;/style&gt; 第三步：挑选相应图标并获取类名，应用于页面：123&lt;svg class=&quot;icon&quot; aria-hidden=&quot;true&quot;&gt; &lt;use xlink:href=&quot;#icon-xxx&quot;&gt;&lt;/use&gt;&lt;/svg&gt; 这里使用了SVG-Sprite，所以使用了js文件将svg嵌入了文档中而不是单独拿出来，因为SVG Sprite只能在同一个文档中使用svg的symbol。因为svg的大小不是不支持font-size修改的，这里用了一个比较hack的方式，就是把图标元素的宽高都写为1em，而em的大小是相对于该元素的字体大小的，这样就实现了svg宽高跟着svg的字体大小一起变了。 3. SVG Sprite:3.1 概述SVG Sprite类似于CSS中的Sprite技术，图标图形整合在一起，实际呈现的时候准确显示特定图标。 123456789101112131415161718192021222324&lt;div&gt; &lt;div&gt; &lt;svg&gt; &lt;!-- 定义图形对象以供重复使用 --&gt; &lt;defs&gt; &lt;g id=&quot;shape&quot;&gt; &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;50&quot; height=&quot;50&quot; /&gt; &lt;circle cx=&quot;0&quot; cy=&quot;0&quot; r=&quot;50&quot; /&gt; &lt;/g&gt; &lt;/defs&gt; &lt;!-- 从svg文档中获取节点，并复制使用 --&gt; &lt;use xlink:href=&quot;#shape&quot; x=&quot;50&quot; y=&quot;50&quot; /&gt; &lt;use xlink:href=&quot;#shape&quot; x=&quot;200&quot; y=&quot;50&quot; /&gt; &lt;/svg&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;垮SVG调用&lt;/h1&gt; &lt;!-- SVG中的use元素可以调用其他SVG文件的元素，只要在一个文档中。 --&gt; &lt;svg width=&quot;500&quot; height=&quot;110&quot;&gt; &lt;use xlink:href=&quot;#shape&quot; x=&quot;50&quot; y=&quot;50&quot; /&gt; &lt;/svg&gt; &lt;/div&gt;&lt;/div&gt; 小结： 跨SVG调用就是“SVG Sprite技术”的核心所在。 在页面载入一个充满Sprite(symbol)的SVG文件（或直接include SVG代码），在页面的任何角落，只要想使用这个图标，通过svg-&gt;use即可。 图标尺寸CSS控制，里面只有一个仅有xlink:href属性的use元素。 3.1 SVG Sprite实际应用3.1.1 svg图标来源 拿来主义,在图库下载 阿里巴巴矢量图标库 icoMoon 自己动手丰衣足食，使用专业的绘图工具[Adobe Illustrator]手动绘制 ###3.1.1 合并svg图标 站在巨人肩膀上使用阿里巴巴矢量图标库或者icoMoon专业矢量图标网站； 自己动手丰衣足食 svg-sprite-loader实现自己的icon组件 原理：利用svg的symbol元素，将每个icon包括在symbol中，通过use元素使用该symbol. 配置步骤如下： 1、安装svg-sprite-loader，配置webpack rules 123456789// 安装 svg-sprite-loader npm install svg-sprite-loader --save // 配置webpack rules&#123; test: /\.svg$/, use:[&#123;loader: &apos;svg-sprite-loader&apos;&#125;],&#125; svg-sprite-loader会把icon塞到一个个symbol中，symbol的id如果不特别指定，就是文件名。它最终会在你的html中嵌入一个svg，你就可以像这样： 使用icon了。 2、引入svg文件 123456789//引入 svgimport default32 from &apos;./icons/assets/default32.svg&apos;;// 使用icon&lt;div&gt; &lt;svg&gt; &lt;use xlinkHref=&#123;`#$&#123;default32.id&#125;`&#125; /&gt; &lt;/svg&gt;&lt;/div&gt; 上面我们的基本功能已经完成了，还有最后一个小小的问题——我们每次引用一个文件的时候就得import一下，这还是很麻烦也不利于项目的管理。 在这里，我们可以使用webpack的require.contextAPI来动态引入所有的Icon. 现在我们是不能动态引入模块，但是webpack为我们提供了相关功能，webpack允许我们使用表达式动态引入模块。比如：require(‘./template/‘+name+’.ejs’);此时webpack会生成一个context module 它接受三个参数，第一个是文件夹，第二个是是否使用子文件，第三个是文件匹配的正则。 1require.context(directory, useSubdirectories = false, regExp = /^\.\//) require.context会返回一个函数，并且该函数有keys()，id，resolve()属性。 keys()方法返回的该模块可以处理的所有可能请求的模块的数组，简单一点就是满足该参数的模块； resolve()返回的是请求的module的id; id是该context module的id; 相关api可以查阅webpack关于require-context 3、组件化 12345678910111213141516171819202122232425// ./icon/index.js 动态引入所有的svg icon // requires and returns all modules that match const requireAll = requireContext =&gt; requireContext.keys().map(requireContext); // import all svg const req = require.context(&apos;./assets&apos;, false, /\.svg$/); export default requireAll(req);// ./Icon.jsx import React,&#123;Component&#125; from &apos;react&apos; import iconImg from &apos;./icons/index.js&apos;; export default class Icon extends Component&#123; render()&#123; const &#123; name &#125; = this.props; const symbolId = iconImg.find((&#123;default:&#123;id&#125;&#125;)=&gt;id===name) return ( &lt;div&gt; &lt;svg&gt; &lt;use xlinkHref=&#123;`#$&#123;symbolId.default.id&#125;`&#125; /&gt; &lt;/svg&gt; &lt;/div&gt; ) &#125; &#125; 小结 @font-face 自定义一个字体； Unicode、Font-class、Symbol引入字体； SVG Sprite 原理及应用。 参考链接： 浏览器字体渲染 使用阿里矢量图标库操作流程 SVG Sprite技术介绍 真正了解CSS3背景下的@font face规则 webpack插件svg-sprite-loader–实现自己的icon组件]]></content>
      <categories>
        <category>css 高级</category>
      </categories>
      <tags>
        <tag>css高级, -iconFont, -svg-sprite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css属性:动画(Animation)]]></title>
    <url>%2FBlog%2F2018%2F09%2F28%2Fanimation%2F</url>
    <content type="text"><![CDATA[参考链接： css.doyoe.com css2.1中文版 MDN animation 概述 animation属性是如下属性的一个简写属性形式: animation-name: 检索或设置对象所应用的动画名称 animation-duration: 检索或设置对象动画的持续时间 animation-timing-function: 检索或设置对象动画的过渡类型 animation-delay: 检索或设置对象动画延迟的时间 animation-iteration-count: 检索或设置对象动画的循环次数 animation-direction: 检索或设置对象动画在循环中是否反向运动 animation-fill-mode: 检索或设置对象动画时间之外的状态 animation-play-state: 检索或设置对象动画的状态。w3c正考虑是否将该属性移除，因为动画的状态可以通过其它的方式实现，比如重设样式 123456默认值： 看每个独立属性适用于： 所有元素，包含伪对象:after和:before继承性： 无动画性： 否计算值： 看每个独立属性媒体： 视觉 animation-name概述animation-name属性指定应用的一系列动画，每个名称代表一个由@keyframes定义的动画序列 1234567默认值： none适用于： 所有元素，包含伪对象:after和:before继承性： 无动画性： 否计算值： 指定值媒体： 视觉相关属性： [ @keyframes ] 示例1234567891011121314/* Single animation */animation-name: none;animation-name: test_05;animation-name: -specific;animation-name: sliding-vertically;/* Multiple animations */animation-name: test1, animation4;animation-name: none, -moz-specific, sliding;/* Global values */animation-name: initialanimation-name: inheritanimation-name: unset 语法 none: 特殊关键字，表示无关键帧。可以不改变其他标识符的顺序而使动画失效，或者使层叠的动画样式失效。 &lt;IDENT&gt;: 标识动画的字符串，由大小写不敏感的字母a-z、数字0-9、下划线(_)和/或横线(-)组成。第一个非横线字符必须是字母，数字不能在字母前面，不允许两个横线出现在开始位置。 animation-duration概述animation-duration属性指定一个动画周期的时长。默认值为0s，表示无动画。 123456默认值： 0s适用于： 所有元素，包含伪对象:after和:before继承性： 无动画性： 否计算值： 指定值媒体： 视觉 语法 &lt;time&gt;：一个动画周期的时长，单位为秒(s)或者毫秒(ms)，无单位值无效。 1234animation-duration: 6sanimation-duration: 120msanimation-duration: 1s, 15sanimation-duration: 10s, 30s, 230ms animation-timing-function概述animation-timing-function属性定义CSS动画在每一动画周期中执行的节奏。可能值为一或多个 &lt;timing-function&gt;。 123456默认值： ease适用于： 所有元素，包含伪对象:after和:before继承性： 无动画性： 否计算值： 指定值媒体： 视觉 语法123456789101112131415161718192021/* Keyword values */animation-timing-function: ease;animation-timing-function: ease-in;animation-timing-function: ease-out;animation-timing-function: ease-in-out;animation-timing-function: linear;animation-timing-function: step-start;animation-timing-function: step-end;/* Function values */animation-timing-function: cubic-bezier(0.1, 0.7, 1.0, 0.1);animation-timing-function: steps(4, end);animation-timing-function: frames(10);/* Multiple animations */animation-timing-function: ease, step-start, cubic-bezier(0.1, 0.7, 1.0, 0.1);/* Global values */animation-timing-function: inherit;animation-timing-function: initial;animation-timing-function: unset; &lt;timing-function&gt; linear：线性过渡。等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0) ease：平滑过渡。等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0) ease-in：由慢到快。等同于贝塞尔曲线(0.42, 0, 1.0, 1.0) ease-out：由快到慢。等同于贝塞尔曲线(0, 0, 0.58, 1.0) ease-in-out：由慢到快再到慢。等同于贝塞尔曲线(0.42, 0, 0.58, 1.0) step-start：等同于 steps(1, start) step-end：等同于 steps(1, end) steps([, [ start | end ] ]?)：接受两个参数的步进函数。第一个参数必须为正整数，指定函数的步数。第二个参数取值可以是start或end，指定每一步的值发生变化的时间点。第二个参数是可选的，默认值为end。 cubic-bezier(, , , )：特定的贝塞尔曲线类型，4个数值需在[0, 1]区间内 animation-delay概述animation-delay属性定义动画于何时开始，即从动画应用在元素上到动画开始的这段时间的延迟多久。 123456默认值： 0s适用于： 所有元素，包含伪对象:after和:before继承性： 无动画性： 否计算值： 指定值媒体： 视觉 0s是该属性的默认值，代表动画在应用到元素上后立即开始执行。否则，该属性的值代表动画样式应用到元素上后会延迟执行； 定义一个负值会让动画立即开始。但是动画会从它的动画序列中某位置开始。例如，如果设定值为-1s，动画会从它的动画序列的第1秒位置处立即开始。 如果为动画延迟指定了一个负值，但起始值是隐藏的，则从动画应用于元素的那一刻起就获取起始值。 语法12animation-delay: 3s;animation-delay: 2s, 4ms; &lt;time&gt;从动画样式应用到元素上到元素开始执行动画的时间差（延迟）。该值可用单位为秒(s)和毫秒(ms)。如果未设置单位，定义无效。 animation-iteration-count概述animation-iteration-count属性定义动画循环播放的次数。默认次数为1。 123456默认值： 1适用于： 所有元素，包含伪对象:after和:before继承性： 无动画性： 否计算值： 指定值媒体： 视觉 语法1234animation-iteration-count: infinite;animation-iteration-count: 3;animation-iteration-count: 2.3;animation-iteration-count: 2, 0, infinite; infinite: 无限循环播放。 &lt;number&gt;: 动画播放的次数 不可为负值。 可以用小数定义循环(0.5 将播放动画到关键帧的一半（from 0 ~ 50%)。 animation-direction概述animation-direction 属性指示动画是否反向播放。 123456默认值： normal适用于： 所有元素，包含伪对象:after和:before继承性： 无动画性： 否计算值： 指定值媒体： 视觉 语法123456animation-direction: normalanimation-direction: reverseanimation-direction: alternateanimation-direction: alternate-reverseanimation-direction: normal, reverseanimation-direction: alternate, reverse, normal normal: 每个循环内动画向前循环，换言之，每个动画循环结束，动画重置到起点重新开始，这是默认属性 alternate: 动画交替反向运行，反向运行时，动画按步后退，同时，带时间功能的函数也反向，比如，ease-in 在反向时成为ease-out。计数取决于开始时是奇数迭代还是偶数迭代 reverse: 反向运行动画，每周期结束动画由尾到头运行 alternate-reverse: 反向交替， 反向开始交替。动画第一次运行时是反向的，然后下一次是正向，后面依次循环。决定奇数次或偶数次的计数从1开始 animation-play-state概述animation-play-state 属性定义一个动画是否运行或者暂停。 可以通过查询它来确定动画是否正在运行。另外，它的值可以被设置为暂停和恢复的动画的重放。 恢复一个已暂停的动画，将从它开始暂停的时候，而不是从动画序列的起点开始在动画。 语法1234567891011/* Single animation */animation-play-state: running;animation-play-state: paused;/* Multiple animations */animation-play-state: paused, running, running;/* Global values */animation-play-state: inherited;animation-play-state: initial;animation-play-state: unset; running: 运行 paused： 停止 animation-fill-mode概述animation-fill-mode 属性用来指定在动画执行之前和之后如何给动画的目标应用样式。 123456默认值： none适用于： 所有元素，包含伪对象:after和:before继承性： 无动画性： 否计算值： 指定值媒体： 视觉 语法123456789animation-fill-mode: noneanimation-fill-mode: forwardsanimation-fill-mode: backwardsanimation-fill-mode: both/* 可以应用多个参数，这个时候使用逗号隔开 *//* 各个参数应用于与次序相对应的动画名 */animation-fill-mode: none, backwardsanimation-fill-mode: both, forwards, none none: 默认值。不设置对象动画之外的状态 forwards: 目标保持动画最后一帧的样式，最后一帧是哪个取决于animation-direction和 animation-iteration-count: animation-direction animation-iteration-count last keyframe encountered normal even or odd 100% or to reverse even or odd 0% or from alternate even 0% or from alternate odd 100% or to alternate-reverse even 100% or to alternate-reverse odd 0% or from backwards: 动画采用相应第一帧的样式，保持 animation-delay，第一帧取法如下： animation-direction first relevant keyframe normal or alternate 0% or from reverse or alternate-reverse 100% or to both: 动画将会执行 forwards 和 backwards 执行的动作。 @keyframe 关键帧概述@keyframes 规则通过在动画序列中定义关键帧（或waypoints）的样式来控制CSS动画序列中的中间步骤。 @keyframes定义的动画名称用来被animation-name所使用 定义动画时，简单的动画可以直接使用关键字from和to，即从一种状态过渡到另一种状态 如果复杂的动画，可以混合去设置某个时间段内的任意时间点的样式 当然，也可以不使用关键字from和to，而都使用 注意： ==让关键帧序列生效== 如果一个关键帧规则没有指定动画的开始或结束状态（也就是，0%/from 和100%/to，浏览器将使用元素的现有样式作为起始/结束状态。这可以用来从初始状态开始元素动画，最终返回初始状态。 如果在关键帧的样式中使用了不能用作动画的属性，那么这些属性会被忽略掉，支持动画的属性仍然是有效的，不受波及。 ==重复定义(Duplicate resolution)== 如果多个关键帧使用同一个名称，以最后一次定义的为准。 @keyframes 不存在层叠样式(cascade)的情况，所以动画在一个时刻（阶段）只会使用一个的关键帧的数据。 如果一个@keyframes 里的关键帧的百分比存在重复的情况，以最后一次定义的关键帧为准。 因为@keyframes 的规则不存在层叠样式(cascade)的情况，即使多个关键帧设置相同的百分值也不会全部执行。 ==属性个数不定== 如果一个关键帧中没有出现其他关键帧中的属性，那么这个属性将使用插值(不能使用插值的属性除外, 这些属性会被忽略掉) 1234567@keyframes identifier &#123; 0% &#123; top: 0; left: 0; &#125; 30% &#123; top: 50px; &#125; 68%, 72% &#123; left: 50px; &#125; 100% &#123; top: 100px; left: 100%; &#125;&#125;//例子中，&quot;top&quot;属性分别出现在 0%, 30%和100%的关键帧中，&quot;left&quot;属性分别出现在0%, 68%和100% 关键帧中. ==当关键帧被重复定义== 如果某一个关键帧出现了重复的定义，且重复的关键帧中的css属性值不同，以最后一次定义的属性为准。 ==关键帧中的 !important 关键词== 关键帧中出现的 !important 关键词将会被忽略 123456789101112@keyframes important1 &#123; from &#123; margin-top: 50px; &#125; 50% &#123; margin-top: 150px !important; &#125; /* 忽略 */ to &#123; margin-top: 100px; &#125;&#125;@keyframes important2 &#123; from &#123; margin-top: 50px; margin-bottom: 100px; &#125; to &#123; margin-top: 150px !important; /* 忽略 */ margin-bottom: 50px; &#125;&#125; 语法 &lt;identifier&gt;帧列表的名称。 名称必须符合 CSS 语法中对标识符的定义。 from等效于 0%. to等效于 100%. &lt;percentage&gt;动画序列中，触发关键帧的时间点，使用百分值来表示。 animation代码实例，旋转的正方体 系列动画]]></content>
      <categories>
        <category>css basic</category>
      </categories>
      <tags>
        <tag>css基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css属性:变化(Transform)]]></title>
    <url>%2FBlog%2F2018%2F09%2F27%2Ftransform%2F</url>
    <content type="text"><![CDATA[参考链接： css.doyoe.com css2.1中文版 MDN transform 概述 transform 属性允许你修改CSS视觉格式模型的坐标空间。使用它，元素可以被转换（translate）、旋转（rotate）、缩放（scale）、倾斜（skew） CSS transform 属性 , 只对 block 级元素生效！ 123456初始值 none适用元素 可变换元素是否是继承属性 否适用媒体 视觉计算值 指定值，但相对长度会转换为绝对长度动画性 是 示例123456789101112131415161718192021222324252627282930313233/* Keyword values */transform: none;/* Function values */transform: matrix(1.0, 2.0, 3.0, 4.0, 5.0, 6.0);transform: translate(12px, 50%);transform: translateX(2em);transform: translateY(3in);transform: scale(2, 0.5);transform: scaleX(2);transform: scaleY(0.5);transform: rotate(0.5turn);transform: skew(30deg, 20deg);transform: skewX(30deg);transform: skewY(1.07rad);transform: matrix3d(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0);transform: translate3d(12px, 50%, 3em);transform: translateZ(2px);transform: scale3d(2.5, 1.2, 0.3);transform: scaleZ(0.3);transform: rotate3d(1, 2.0, 3.0, 10deg);transform: rotateX(10deg);transform: rotateY(10deg);transform: rotateZ(10deg);transform: perspective(17px);/* Multiple function values */transform: translateX(10px) rotate(10deg) translateY(5px);/* Global values */transform: inherit;transform: initial;transform: unset; 语法 &lt;transform-function&gt;至少一个 CSS transform functions 被应用 none指定为 不应用transform 2D变化 matrix() 用六个指定的值来指定一个均匀的二维（2D）变换矩阵 12345678910111213141516171819transform: matrix(a, c, b, d, tx, ty)/* a, b, c, d 创建了变形矩阵 ┌ ┐ │ a b │ │ c d │ └ ┘ tx, ty是变形的值 . */ 1.平移效果：transform: matrix(1, 0, 0, 1, tx, ty);等同于transform：translate(tx, ty);2.缩放效果：transform: matrix(sx,0,0,sy,0,0); 等同于transform：scale(sx, sy);3.旋转效果：transform: matrix(cosθ,sinθ,-sinθ,cosθ,0,0); 等同于transform：rotate(θ); 4.拉伸效果：transform：matrix(1,tan(θy),tan(θx),1,0,0); 等同于transform: skew(θx + &quot;deg&quot;，θy+ &quot;deg&quot;); css transform matrix 工具 translate() 指定对象的2D translation（2D平移）。第一个参数对应X轴，第二个参数对应Y轴。如果第二个参数未提供，则默认值为0 translateX() 指定对象X轴（水平方向）的平移，translate(tx, 0) 的简写形式 translateY() 指定对象Y轴（垂直方向）的平移，translate(0, ty)的简写形式 rotate() 指定对象的2D rotation（2D旋转），需先有 &lt;’ transform-origin ‘&gt; 属性的定义。移动量由指定角度定义;如果为正值，则运动将为顺时针，如果为负值，则为逆时针 。 180°的旋转称为点反射 (point reflection)。 12rotate(&lt;angle&gt;)&lt;angle&gt; 代表旋转的角度。正角表示顺时针旋转，负角表示逆时针旋转 scale() 指定对象的2D scale（2D缩放）。第一个参数对应X轴，第二个参数对应Y轴。如果第二个参数未提供，则默认取第一个参数的值。 当超出 [-1, 1]范围外时，缩放将在坐标方向上放大元素；当在该范围内时，它在该方向收缩元素。当等于1时，它什么也不做，当它为负时，它执行点反射和大小修改。 12scale(sx) orscale(sx, sy) scaleX() 指定对象X轴的（水平方向）缩放 scaleX(sx) 是 scale(sx, 1) 和 scale3d(sx, 1, 1) 的简写形式。 scaleX(-1) 表示通过原点的垂直轴定义轴对称（由 transform-origin 属性指定）。 scaleY() 指定对象Y轴的（垂直方向）缩放 scaleY(sy) 是 scale(1, sy) 和 scale3d(1, sy, 1) 的简写形式。 scaleY(-1) 定义了通过原点的水平轴的轴对称（由 transform-origin 属性指定）。 skew() 指定对象skew transformation（斜切扭曲）。第一个参数对应X轴，第二个参数对应Y轴。如果第二个参数未提供，则默认值为0 ==注意css斜切坐标系的x，y轴== skewX()指定对象X轴的（水平方向）扭曲 skewY()指定对象Y轴的（垂直方向）扭曲 Transform 2D 代码演示 3D变化 matrix3d() 用一个 4 × 4 的齐次矩阵来描述一个三维（3D）变换 123456789101112131415161718192021transform: matrix3d(a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3, a4, b4, c4, d4);1.平移变换X, 对应translateX(tx)：matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, 0, 0, 1)2.平移变换Y, 对应translateY(ty)：matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, ty, 0, 1)3.平移变换，对应translateZ(tz)：matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, tz, 1)4.多维平移:matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,tx,ty,tz,1)5.多维尺度：matrix3d(cx, 0, 0, 0, 0, cy, 0, 0, 0, 0, cz, 0, 0, 0, 0, 1 );6.旋转变换：X轴：matrix3d(1,0,0,0,0,cos(θ),sin(θ),0,0,-sin(θ),cos(θ),0,0,0,0,1);Y轴：matrix3d(cos(θ),0,-sin(θ),0,0,1,0,0,sin(θ),0,cos(θ),0,0,0,0,1);Z轴：matrix3d(cos(θ),sin(θ),0,0,-sin(θ),cos(θ),0,0,0,0,1,0,0,0,0,1); translate3d() 指定对象的3D位移。第1个参数对应X轴，第2个参数对应Y轴，第3个参数对应Z轴，参数不允许省略 Transform 3D 代码演示 transform-origin概述transform-origin 属性让你更改一个元素变形的原点。 123456初始值 50% 50% 0适用于 可变换元素是否可继承 否适用媒体 视觉计算值 除了指定绝对值，否则都为百分比动画性 当值为数值时 示例1234567891011121314151617181920212223242526272829303132/* One-value syntax */transform-origin: 2px;transform-origin: bottom;/* x-offset | y-offset */transform-origin: 3cm 2px;/* x-offset-keyword | y-offset */transform-origin: left 2px;/* x-offset-keyword | y-offset-keyword */transform-origin: right top;/* y-offset-keyword | x-offset-keyword */transform-origin: top right;/* x-offset | y-offset | z-offset */transform-origin: 2px 30% 10px;/* x-offset-keyword | y-offset | z-offset */transform-origin: left 5px -3px;/* x-offset-keyword | y-offset-keyword | z-offset */transform-origin: right bottom 2cm;/* y-offset-keyword | x-offset-keyword | z-offset */transform-origin: bottom right 2cm;/* Global values */transform-origin: inherit;transform-origin: initial;transform-origin: unset; transform-origin属性可以使用一个，两个或三个值来指定，其中每个值都表示一个偏移量。 没有明确定义的偏移将重置为其对应的初始值。 如果定义了两个或更多值并且没有值的关键字，或者唯一使用的关键字是center，则第一个值表示水平偏移量，第二个值表示垂直偏移量。 一个值： 必须是，，或 left, center, right, top, bottom关键字中的一个。 两个值： 其中一个必须是，，或left, center, right关键字中的一个。 另一个必须是，，或top, center, bottom关键字中的一个。 三个值： 前两个值和只有两个值时的用法相同。 第三个值必须是。它始终代表Z轴偏移量。 语法 x-offset 定义变形中心距离盒模型的左侧的或偏移值。 offset-keyword left，right，top，bottom或center中之一，定义相对应的变形中心偏移。 y-offset 定义变形中心距离盒模型的顶的或偏移值。 x-offset-keyword left，right或center中之一，定义相对应的变形中心偏移。 y-offset-keyword top，bottom或center中之一，定义相对应的变形中心偏移。 z-offset 定义变形中心距离用户视线（z=0处）的（不能是）偏移值。 keyword value left 0% center 50% right 100% top 0% bottom 100% transform-origin 代码示例 transform-style概述123456初始值 flat适用元素 可变换元素是否是继承属性 否适用媒体 视觉计算值 指定值动画性 否 示例1234transform-style: preserve-3dtransform-style: flattransform-style: inherit 语法 preserve-3d 指定子元素定位在三维空间内 flat 指定子元素位于此元素所在平面内 perspective概述 perspective 属性指定了观察者与z=0平面的距离，使具有三维位置变换的元素产生透视效果。z&gt;0的三维元素比正常大，而z&lt;0时则比正常小，大小程度由该属性的值决定。 三维元素在观察者后面的部分不会绘制出来，即z轴坐标值大于perspective属性值的部分。 默认情况下，消失点位于元素的中心，但是可以通过设置perspective-origin属性来改变其位置。 当该属性值不为0和none时，会创建新的层叠上下文。 123456默认值： none适用于： 变换元素继承性： 无动画性： 当值为&lt;length&gt;时计算值： 绝对长度或「none」媒体： 视觉 示例1234567891011/* Keyword value */perspective: none;/* &lt;length&gt; values */perspective: 20px; perspective: 3.5em;/* Global values */perspective: inherit;perspective: initial;perspective: unset; perspective 代码实例 perspective-origin概述perspective-origin属性决定了观察者正在观看的位置，即灭点(vanishing point)位置。 123456默认值 50% 50%，效果等同于center center适用于 可变换元素继承性 无动画性 当值为数值时计算值 除了指定绝对值，否则都为百分比媒体 视觉 示例1234567891011121314/* One-value syntax */perspective-origin: x-position;/* Two-value syntax */perspective-origin: x-position y-position;/* When both x-position and y-position are keywords, the following is also valid */perspective-origin: y-position x-position;/* Global values */perspective-origin: inherit;perspective-origin: initial;perspective-origin: unset; 该属性提供2个参数值。 如果提供两个，第一个用于横坐标，第二个用于纵坐标。 如果只提供一个，该值将用于横坐标；纵坐标将默认为center。 语法 x-position指定消失点的横坐标，其值有以下形式： 百分比，相对于元素宽度，可为负值。 长度值，可为负值。 left，关键字，0值的简记。 center，关键字，50%的简记。 right，关键字，100%的简记。 y-position指定消失点的纵坐标，其值有以下形式： - 百分比，相对于元素的高度，可为负值。 长度值，可为负值。 top，关键字，0值得简记。 center，关键字，50%的简记。 bottom，关键字，100%的简记。 perspective-origin代码示例 backface-visibility概述backface-visibility属性指定当元素背面朝向观察者时是否可见。元素的背面总是透明的，当其朝向观察者时，显示正面的镜像。 决定一个元素背面面向用户时是否可见，需要直接在该元素上定义backface-visibility属性，而不能在其父元素上，因为该属性默认为不可继承。 因为2D变换无透视效果，故该属性对2D变换无效。 123456默认值 visible适用于 变换元素继承性 无动画性 否计算值 指定值媒体 视觉 示例12backface-visibility: visiblebackface-visibility: hidden 语法 visible：指定元素背面可见，允许显示正面的镜像。 hidden：指定元素背面不可见 backface-visibility代码实例]]></content>
      <categories>
        <category>css basic</category>
      </categories>
      <tags>
        <tag>css基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css属性:过渡(Transition)]]></title>
    <url>%2FBlog%2F2018%2F09%2F27%2Ftransition%2F</url>
    <content type="text"><![CDATA[参考链接： css.doyoe.com css2.1中文版 MDN transition 概述CSS transitions 提供了一种在更改CSS属性时控制动画速度的方法。 其可以让属性变化成为一个持续一段时间的过程，而不是立即生效的。比如，将一个元素的颜色从白色改为黑色，通常这个改变是立即生效的，使用 CSS transitions 后该元素的颜色将逐渐从白色变为黑色，按照一定的曲线速率变化。这个过程可以自定义。通常将两个状态之间的过渡称为隐式过渡（implicit transitions），因为开始与结束之间的状态由浏览器决定。 CSS transitions 可以决定哪些属性发生动画效果 (明确地列出这些属性)， 何时开始 (设置 delay）， 持续多久 (设置 duration) 以及如何动画 (定义timing funtion，比如匀速地或先快后慢)。 12345678910默认值:- transition-delay: 0s- transition-duration: 0s- transition-property: all- transition-timing-function: ease适用于： 所有元素，包含伪对象:after和:before继承性： 无动画性： 否计算值： 看每个独立属性媒体： 交互 参考：可动画属性列表 语法transition是一个简写属性，用于transition-property, transition-duration, transition-timing-function, 和 transition-delay。 1234567891011121314151617181920212223/* Apply to 1 property *//* property name | duration */transition: margin-right 4s;/* property name | duration | delay */transition: margin-right 4s 1s;/* property name | duration | timing function */transition: margin-right 4s ease-in-out;/* property name | duration | timing function | delay */transition: margin-right 4s ease-in-out 1s;/* Apply to 2 properties */transition: margin-right 4s, color 1s;/* Apply to all changed properties */transition: all 0.5s ease-out;/* Global values */transition: inherit;transition: initial;transition: unset; 注意：在transition属性中，各个值的书写顺序是很重要的：第一个可以解析为时间的值会被赋值给transition-duration，第二个可以解析为时间的值会被赋值给transition-delay。 transition-property概述transition-property 指定应用过渡属性的名称 123456默认值： all适用于： 所有元素，包含伪对象:after和:before继承性： 无动画性： 否计算值： 指定值媒体： 视觉 语法123456789101112131415161718/* Keyword values */transition-property: none;transition-property: all;/* &lt;custom-ident&gt; values */transition-property: test_05;transition-property: -specific;transition-property: sliding-vertically;/* Multiple values */transition-property: test1, animation4;transition-property: all, height, all;transition-property: all, -moz-specific, sliding;/* Global values */transition-property: inherit;transition-property: initial;transition-property: unset; none：没有过渡动画。 all：所有可被动画的属性都表现出过渡动画。 IDENT：属性名称。由小写字母 a 到 z，数字 0 到 9，下划线（_）和破折号（-）。第一个非破折号字符不能是数字。同时，不能以两个破折号开头。参考：可动画属性列表 transition-duration概述transition-duration 属性以秒或毫秒为单位指定过渡动画所需的时间。默认值为 0s ，表示不出现过渡动画。 可以指定多个时长，每个时长会被应用到由 transition-property 指定的对应属性上。如果指定的时长个数小于属性个数，那么时长列表会重复。如果时长列表更长，那么该列表会被裁减。两种情况下，属性列表都保持不变。 123456默认值： 0s适用于： 所有元素，包含伪对象:after和:before继承性： 无动画性： 否计算值： 指定值媒体： 交互 语法12345678910/* &lt;time&gt; 值 */transition-duration: 6s;transition-duration: 120ms;transition-duration: 1s, 15s;transition-duration: 10s, 30s, 230ms;/* 全局值 */transition-duration: inherit;transition-duration: initial;transition-duration: unset; &lt;time&gt;&lt;time类型&gt;。表示过渡属性从旧的值转变到新的值所需要的时间。如果时长是 0s ，表示不会呈现过渡动画，属性会瞬间完成转变。不接受负值。 transition-timing-function概述CSS属性受到 transition effect的影响，会产生不断变化的中间值，而 CSS transition-timing-function 属性用来描述这个中间值是怎样计算的。实质上，通过这个函数会建立一条加速度曲线，因此在整个transition变化过程中，变化速度可以不断改变。 123456默认值： ease适用于： 所有元素，包含伪对象:after和:before继承性： 无动画性： 否计算值： 指定值媒体： 交互 语法12345678910111213transition-timing-function: easetransition-timing-function: ease-intransition-timing-function: ease-outtransition-timing-function: ease-in-outtransition-timing-function: lineartransition-timing-function: cubic-bezier(0.1, 0.7, 1.0, 0.1)transition-timing-function: step-starttransition-timing-function: step-endtransition-timing-function: steps(4, end)transition-timing-function: ease, step-start, cubic-bezier(0.1, 0.7, 1.0, 0.1)transition-timing-function: inherit 通过transition-property中定义被过渡属性，每个 的值代表与这个属性相对应的timing function. cubic-bezier(x1, y1, x2, y2): 特定的贝塞尔曲线类型，4个数值需在[0, 1]区间内 steps(number_of_steps, direction): 接受两个参数的步进函数。第一个参数必须为正整数，指定函数的步数。第二个参数取值可以是start或end，指定每一步的值发生变化的时间点。第二个参数是可选的，默认值为end。 step-start：等同于 steps(1, start) step-end：等同于 steps(1, end) ease-in-out: 由慢到快再到慢。等同于贝塞尔曲线(0.42, 0, 0.58, 1.0) ease-out：由快到慢。等同于贝塞尔曲线(0, 0, 0.58, 1.0) ease-in：由慢到快。等同于贝塞尔曲线(0.42, 0, 1.0, 1.0) ease: 平滑过渡。等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0) linear: 线性过渡。等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0) transition-delay概述 transition-delay属性规定了在过渡效果开始作用之前需要等待的时间。 值以秒（s）或毫秒（ms）为单位，表明动画过渡效果将在何时开始。取值为正时会延迟一段时间来响应过渡效果；取值为负时会导致过渡立即开始。 123456默认值： 0适用于： 所有元素，包含伪对象:after和:before继承性： 无动画性： 否计算值： 指定值媒体： 交互 语法12345678/* &lt;time&gt;?值 */transition-delay: 3s;transition-delay: 2s, 4ms;/* 全局变量 */transition-delay: inherit;transition-delay: initial;transition-delay: unset; &lt;time&gt;表明动画效果属性生效之前需要等待的时间。 transition代码实例]]></content>
      <categories>
        <category>css basic</category>
      </categories>
      <tags>
        <tag>css基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序]]></title>
    <url>%2FBlog%2F2018%2F09%2F19%2FwechartMiniProgram%2F</url>
    <content type="text"><![CDATA[项目结构 1234567891011121314151617- page- - index- - - index.js- - - index.json- - - index.wxml- - - index.wxss- - log- - - log.js- - - log.json- - - log.wxml- - - log.wxss- utils- - util.js- app.js- app.json- app.wxss- project.config.json 四类文档： .json：配置文件 .wxml：模板文件 .wxss：样式文件 .js： js文件 配置文件 全局配置 123456789101112131415161718192021222324252627282930313233&#123; &quot;pages&quot;: [ &quot;pages/index/index&quot;, &quot;pages/logs/index&quot; ], &quot;window&quot;: &#123; &quot;backgroundTextStyle&quot;: &quot;light&quot;, //下拉 loading 的样式，仅支持 dark / light &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;, //导航栏背景颜色 &quot;navigationBarTitleText&quot;: &quot;Demo&quot;, //导航栏标题文字内容 &quot;navigationBarTextStyle&quot;: &quot;black&quot;, //导航栏标题颜色，仅支持 black / white &quot;enablePullDownRefresh&quot;: true, //是否全局开启下拉刷新 &quot;backgroundColor&quot;: &quot;#000&quot; //页面上拉触底事件触发时距页面底部距离，单位为px &#125;, &quot;tabBar&quot;: &#123; &quot;color&quot;:&quot;#00ff00&quot;, //字体颜色； &quot;selectedColor&quot;: &quot;#ff0000&quot;, //选中tab字体颜色； &quot;backgroundColor&quot;: &quot;yellow&quot;, //tab背景颜色； &quot;borderStyle&quot;: &quot;black&quot;, //tab边框，只能为black和white； &quot;position&quot;:&quot;bottom&quot;, //tabBar位置； &quot;list&quot;: [&#123; //只能配置最少2个、最多5个 tab &quot;pagePath&quot;: &quot;pages/index/index&quot;, &quot;text&quot;: &quot;首页&quot; &#125;, &#123; &quot;pagePath&quot;: &quot;pages/logs/logs&quot;, &quot;text&quot;: &quot;日志&quot; &#125;] &#125;, &quot;networkTimeout&quot;: &#123; &quot;request&quot;: 10000, &quot;downloadFile&quot;: 10000 &#125;, &quot;debug&quot;: true&#125; 页面配置 123456789101112&#123; &quot;navigationBarBackgroundColor&quot;: &quot;#fff”, //导航栏背景颜色 &quot;navigationBarTitleText&quot;: &quot;WeChat”, //导航栏标题文字内容 &quot;navigationBarTextStyle&quot;:&quot;black”, //导航栏标题颜色，仅支持 black / white &quot;backgroundTextStyle&quot;:&quot;light”, //下拉 loading 的样式，仅支持 dark / light &quot;backgroundColor&quot;: &quot;#ffffff&quot;, //窗口的背景色 &quot;enablePullDownRefresh&quot;: false, //是否开启下拉刷新。 &quot;onReachBottomDistance”: 50, //页面上拉触底事件触发时距页面底部距离，单位为px //只在页面配置中有效，无法在 app.json 中设置 &quot;disableScroll&quot;: false, //设置为 true 则页面整体不能上下滚动；&#125; 逻辑层注册小程序 App(Object)：注册小程序，只能在app.js里面调用，且只能调用一次 1234567891011121314151617181920App(&#123; onLaunch: function(&#123; //小程序初始化完成时触发，全局只触发一次。 path, //打开小程序的路径 query, //打开小程序的query scene, //打开小程序的场景 referrerInfo:&#123; //当场景为由从另一个小程序或公众号或App打开时，返回此字段 appId, //部分场景支持 extraData, //数据 &#125;, &#125;) &#123;&#125;, onShow: function(options) &#123;&#125;, //小程序启动，或从后台进入前台显示时触发。options和onLaunch一样 onHide: function() &#123;&#125;, //小程序从前台进入后台时触发。 onError: function(msg) &#123;&#125;, onPageNotFound: function(&#123; //小程序初始化完成时触发，全局只触发一次。 path, //不存在页面的路径 query, //打开不存在页面的query isEntryPage: true, //是否本次启动的首个页面 &#125;) &#123;&#125;, globalData: &apos;I am global data’ //自定义数据，用this可以访问。&#125;) getApp()：获取App实例 12var appInstance = getApp()console.log(appInstance.globalData) // I am global data 注册页面 Page(Object) 1234567891011121314151617181920212223242526272829303132333435Page(&#123; data, //初始化数据 //以下为生命周期函数 onLoad: function(&#123; //页面加载时触发。一个页面只会调用一次。 query, &#125;) &#123;&#125;, onShow: function(options) &#123;&#125;, //页面显示/切入前台时触发 onReady: function() &#123;&#125;, //初次渲染完成时触发。一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。 onHide: function(options) &#123;&#125;, //页面隐藏/切入后台时触发 onUnload: function(msg) &#123;&#125;, //页面卸载时触发 //以下为事件处理函数 onPullDownRefresh: function() &#123;&#125;, //监听用户下拉刷新事件。 【wx.startPullDownRefresh，wx.stopPullDownRefresh】 onReachBottom: function() &#123;&#125;, //监听用户上拉触底事件 onPageScroll: function(&#123; //页面卸载时触发 srollTop, //页面在垂直方向已经滚动的距离 &#125;) &#123;&#125;, onShareAppMessage: function(&#123; //监听用户点击页面内转发按钮（&lt;button&gt; 组件 open-type=&quot;share&quot;）或右上角菜单“转发”按钮的行为 from, //1, button; 2, menu target, // button||undefined webViewUrl, //页面中包含&lt;web-view&gt;组件时，返回当前&lt;web-view&gt;的url &#125;) &#123; return &#123; title, //转发标题 path, //转发路径 imageUrl, //转发封面图片 &#125; &#125;, onTabItemTap: function(&#123; //点击 tab 时触发，1.9.0版本以上 index, //被点击tabItem的序号，从0开始 pagePath, // 被点击tabItem的页面路径 text, //被点击tabItem的按钮文字 &#125;) &#123;&#125;, &#125;) Page.setData() Page.route 视图层数据绑定1&lt;view&gt; &#123;&#123;message&#125;&#125; &lt;/view&gt; 条件渲染 ： wx:if， wx:elif，wx:else12345&lt;view class=&apos;test-view test-view-if&apos;&gt; &lt;text wx:if=&quot;&#123;&#123;length &gt; 5&#125;&#125;&quot;&gt; 1 &lt;/text&gt; &lt;text wx:elif=&quot;&#123;&#123;length &gt; 2&#125;&#125;&quot;&gt; 2 &lt;/text&gt; &lt;text wx:else&gt; 3 &lt;/text&gt;&lt;/view&gt; 列表渲染123456789//默认下标： index， 当前项默认变量：item&lt;view wx:for=&quot;&#123;&#123;array&#125;&#125;&quot;&gt; &#123;&#123;index&#125;&#125;: &#123;&#123;item.message&#125;&#125;&lt;/view&gt;//使用 wx:for-item 可以指定数组当前元素的变量名，使用 wx:for-index 可以指定数组当前下标的变量名&lt;view wx:for=&quot;&#123;&#123;array&#125;&#125;&quot; wx:for-index=&quot;idx&quot; wx:for-item=&quot;itemName&quot;&gt; &#123;&#123;idx&#125;&#125;: &#123;&#123;itemName.message&#125;&#125;&lt;/view&gt; 模板12345678&lt;template name=&quot;msgItem&quot;&gt; &lt;view&gt; &lt;text&gt; &#123;&#123;index&#125;&#125;: &#123;&#123;msg&#125;&#125; &lt;/text&gt; &lt;text&gt; Time: &#123;&#123;time&#125;&#125; &lt;/text&gt; &lt;/view&gt;&lt;/template&gt;&lt;template is=&quot;msgItem&quot; data=&quot;&#123;&#123;...item&#125;&#125;&quot;/&gt; 事件123&lt;view id=&quot;tapTest&quot; data-hi=&quot;WeChat&quot; bindtap=&quot;tapName&quot;&gt; Click me! &lt;/view&gt;&lt;view id=&quot;tapTest&quot; data-hi=&quot;WeChat” bind:tap=&quot;tapName&quot;&gt; Click me! &lt;/view&gt; bind：不阻止冒泡 catch： 阻止冒泡 引用import：可以使用引用文件定义的template &lt;import src=&quot;a.wxml&quot;/&gt; include：类似于将引用文件的全部代码拷贝到引用位置123&lt;include src=&quot;header.wxml&quot;/&gt; &lt;view&gt; body &lt;/view&gt;&lt;include src=&quot;footer.wxml&quot;/&gt; 样式： WXSS对css的两点扩充： 尺寸单位rpx 样式导入： @import &quot;common.wxss&quot;; 支持以下选择器： 选择器 样例 样例描述 .class .intro 选择所有拥有 class=”intro” 的组件 #id #firstname 选择拥有 id=”firstname” 的组件 element view 选择所有 view 组件 element, element view, checkbox 选择所有文档的 view 组件和所有的 checkbox 组件 ::after view::after 在 view 组件后边插入内容 ::before view::before 在 view 组件前面边插入内容 wxs wxs标签 属性名 类型 说明 module String 当前 标签的模块名。必填字段。 src String 引用 .wxs 文件的相对路径。仅当本标签为单闭合标签或标签的内容为空时有效。 .wxs 文件 wxml 通过wxs标签获取； wxs文件通过require 获取 自定义组件组件规则 类似于页面，一个自定义组件由 json wxml wxss js 4个文件组成 json 文件中进行自定义组件声明： component: true 使用Component() 注册组件 使用组件12345&#123; &quot;usingComponents&quot;: &#123; &quot;component-tag-name&quot;: &quot;path/to/the/custom/component&quot; &#125;&#125; slot 向组件传递数据 组件事件： triggerEvent()]]></content>
      <categories>
        <category>wechart</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css属性:内容与媒体查询]]></title>
    <url>%2FBlog%2F2018%2F09%2F12%2Fmedia%2F</url>
    <content type="text"><![CDATA[内容content 用来和:after及:before伪元素一起使用，在对象前或后显示内容。 counter-increment 设定当一个selector发生时计数器增加的值。取值：id number counter-reset 将指定selector的计数器复位。取值：id number12345678910111213normal：默认值。表现与none值相同none：不生成任何值。&lt;attr&gt;：插入标签属性值&lt;url&gt;：使用指定的绝对或相对地址插入一个外部资源（图像，声频，视频或浏览器支持的其他任何资源）&lt;string&gt;：插入字符串counter(name)：使用已命名的计数器counter(name,list-style-type)：使用已命名的计数器并遵从指定的list-style-type属性counters(name,string)：使用所有已命名的计数器counters(name,string,list-style-type)：使用所有已命名的计数器并遵从指定的list-style-type属性no-close-quote：并不插入quotes属性的后标记。但增加其嵌套级别no-open-quote：并不插入quotes属性的前标记。但减少其嵌套级别close-quote：插入quotes属性的后标记open-quote：插入quotes属性的前标记 quotes设置或检索对象内使用的嵌套标记。取值 none | [ ] 媒体查询 通过不同的媒体类型和条件定义样式表规则。 媒体查询让CSS可以更精确作用于不同的媒体类型和同一媒体的不同条件。 媒体查询的大部分媒体特性都接受min和max用于表达“大于或等于”和“小与或等于”。如：width会有min-width和max-width 媒体查询可以被用在CSS中的@media和@import规则上，也可以被用在HTML和XML中。 12345eg:@media screen and (width:800px)&#123; … &#125;@import url(example.css) screen and (width:800px);&lt;link media=&quot;screen and (width:800px)&quot; rel=&quot;stylesheet&quot; href=&quot;example.css&quot; /&gt;&lt;?xml-stylesheet media=&quot;screen and (width:800px)&quot; rel=&quot;stylesheet&quot; href=&quot;example.css&quot; ?&gt; media12345678语法：@media mediatype and|not|only (media feature) &#123; CSS-Code;&#125;针对多个媒体类型的CSS规则，可以用逗号来隔开@media handheld and (min-width:360px),screen and (min-width:480px)&#123;body&#123;font-size:large;&#125;&#125; mediatype12345678910111213媒体类型mediatype 取值有 all：用于所有设备print：用于打印机和打印预览screen: 用于电脑屏幕，平板电脑，智能手机等speech: 应用于屏幕阅读器等发声设备media 4 废弃：braille 盲文embossed 盲文打印handheld 手持设备projection 项目演示，比如幻灯speech 演讲tty 固定字母间距的网格的媒体，比如电传打字机tv 电视 媒体特性width | height 定义输出设备中的页面可见区域宽度/高度 （接受min/max） aspect-ratio 定义输出设备中的页面可见区域宽度与高度的比率 （接受min/max） orientation（判断显示屏横向纵向） 定义输出设备中的页面可见区域高度是否大于或等于宽度 landscape: 设备横向 portrait: 设备纵向 resolution 定义设备的分辨率 eg:96dpi, 300dpi, 118dpcm （接受min/max） scan 定义电视类设备的扫描工序 progressive: 连续扫描 interlace: 交织扫描 grid 用来查询输出设备是否使用栅格或点阵 1代表是，0代表否 color | color-index | monochrome 定义输出设备每一组彩色原件的个数 | 定义在输出设备的彩色查询表中的条目数 | 定义在一个单色框架缓冲区中每像素包含的单色原件个数 （接受min/max） 如果不是彩色设备，则值等于0 media 4废弃，针对移动设备 device-width | device-height | device-aspect-ratio 定义输出设备的屏幕可见宽度宽度/高度 | 输出设备的屏幕可见宽度与高度的比率 （接受min/max） Media Queries Level 4简洁语法123456789简洁语法：@media (height &gt; 600px) &#123; body &#123; line-height: 1.4; &#125;&#125;@media (400px &lt;= width &lt;= 700px) &#123; body &#123; line-height: 1.4; &#125;&#125; update 输出设备修改内容外观的频率 none 渲染后，无法再更新布局。如：打印在纸上的文档。 slow 布局可以根据CSS的通常规则动态地改变，但是输出设备不能足够快地渲染或显示变化以使它们被感知为平滑动画。示例：电子书阅读器或严重不足的设备。 fast 布局可以根据CSS的通常规则动态地改变，并且输出设备的速度不受异常限制，因此可以使用诸如CSS动画之类的定期更新。比如：计算机屏幕。 overflow-block 输出设备如何处理沿块轴溢出视口的内容？ none 不显示溢出块轴的内容。 scroll 通过滚动可以看到溢出块轴的内容。 optional-paged 可以通过滚动查看溢出块轴的内容，但可以手动触发分页符（例如via break-inside等），以使以下内容显示在下一页上。 paged 内容被分解为不连续的页面; 在块轴中溢出一页的内容显示在下一页上。 overflow-inline 可以滚动沿着内联轴溢出视口的内容吗？ none 不显示溢出块轴的内容。 scroll 通过滚动到内容轴可以看到溢出内联轴的内容。]]></content>
      <categories>
        <category>css basic</category>
      </categories>
      <tags>
        <tag>css基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css属性:Selectors选择符]]></title>
    <url>%2FBlog%2F2018%2F09%2F05%2Fselectors%2F</url>
    <content type="text"><![CDATA[元素选择符通配选择符 *选定所有的对象,出于性能考虑通常不建议使用因为会命中文档中所有的元素 123* &#123; rule&#125; 类型选择符以文档语言对象类型作为选择符 123div &#123; rule&#125; ID 选择符以唯一标识符 id 属性作为选择符 123#id &#123; rule&#125; 类选择符以 class 属性为选择符，不通与 ID 属性，class 属性可以定义多个 123.cls &#123; rule&#125; 关系选择符包含选择符(E F)123E F &#123; rule&#125; 选择所有被 E 元素包含的 F 元素。包含选择符将会命中所有符合条件的后代，包括儿子，孙子，孙子的孙子… 子选择符(E &gt; F)123E &gt; F &#123; rule&#125; 选择所有作为 E 元素的子元素 F。与 包含选择符(E F) 不同的是，子选择符只能命中子元素，而不能命中孙辈。 相邻选择符(E + F)选择紧贴在 E 元素之后 F 元素，元素 E 与 F 必须同属一个父级。 See the Pen 相邻选择符 by scliuyang (@scliuyang) on CodePen. 兄弟选择符(E ~ F)选择 E 元素后面的所有兄弟元素 F，元素 E 与 F 必须同属一个父级。 12345678910&lt;style&gt; /* 相邻选择符(E+F) */ h3 + p &#123; color: #f00; &#125; /* 兄弟选择符(E~F) */ h3 ~ p &#123; color: #f00; &#125;&lt;/style&gt;&lt;h3&gt;这是一个标题&lt;/h3&gt;&lt;p&gt;p1&lt;/p&gt;&lt;p&gt;p2&lt;/p&gt;&lt;p&gt;p3&lt;/p&gt; 这个例子中，如果是相邻选择符，那么只有 p1 会变成红色；如果是兄弟选择符，那么 p1/p2/p3 都会变成红色； 属性选择符E[att]选择具有 att 属性的 E 元素。 12345678&lt;style&gt;img[alt] &#123; margin: 10px;&#125;&lt;/style&gt;&lt;img src="图片url" alt="" /&gt;&lt;img src="图片url" /&gt; 此例，将会命中第一张图片，因为匹配到了 alt 属性 E[att=”val”]选择具有 att 属性且属性值等于 val 的 E 元素。 12345678&lt;style&gt;input[type="text"] &#123; border: 2px solid #000;&#125;&lt;/style&gt;&lt;input type="text" /&gt;&lt;input type="submit" /&gt; 此例，将会命中第一张 input，因为匹配到了 type 属性，并且属性值为 text E[att~=”val”]选择具有 att 属性且属性值为一用空格分隔的字词列表，其中一个等于 val 的 E 元素（包含只有一个值且该值等于 val 的情况）。 123456789&lt;style&gt;div[class~="a"] &#123; border: 2px solid #000;&#125;&lt;/style&gt;&lt;div class="a"&gt;1&lt;/div&gt;&lt;div class="b"&gt;2&lt;/div&gt;&lt;div class="a b"&gt;3&lt;/div&gt; 此例，将会命中 1, 3 两个 div，因为匹配到了 class 属性，且属性值中有一个值为 a E[att^=”val”]选择具有 att 属性且属性值为以 val 开头的字符串的 E 元素。 123456789&lt;style&gt;div[class^="a"] &#123; border: 2px solid #000;&#125;&lt;/style&gt;&lt;div class="abc"&gt;1&lt;/div&gt;&lt;div class="acb"&gt;2&lt;/div&gt;&lt;div class="bac"&gt;3&lt;/div&gt; 此例，将会命中 1, 2 两个 div，因为匹配到了 class 属性，且属性值以 a 开头 E[att$=”val”]选择具有 att 属性且属性值为以 val 结尾的字符串的 E 元素。 123456789&lt;style&gt;div[class$="c"] &#123; border: 2px solid #000;&#125;&lt;/style&gt;&lt;div class="abc"&gt;1&lt;/div&gt;&lt;div class="acb"&gt;2&lt;/div&gt;&lt;div class="bac"&gt;3&lt;/div&gt; 此例，将会命中 1, 3 两个 div，因为匹配到了 class 属性，且属性值以 c 结尾 E[att*=”val”]选择具有 att 属性且属性值为包含 val 的字符串的 E 元素。 123456789&lt;style&gt;div[class*="b"] &#123; border: 2px solid #000;&#125;&lt;/style&gt;&lt;div class="abc"&gt;1&lt;/div&gt;&lt;div class="acb"&gt;2&lt;/div&gt;&lt;div class="bac"&gt;3&lt;/div&gt; 此例，将会命中所有 div，因为匹配到了 class 属性，且属性值中都包含了 b E[att|=”val”]如果元素 E 拥有 att 属性，并且值为 val，或者值是以 val-开头的，那么 E 将会被选择。 12345678910&lt;style&gt;div[class|="a"] &#123; border: 2px solid #000;&#125;&lt;/style&gt;&lt;div class="a"&gt;0&lt;/div&gt;&lt;div class="a-test"&gt;1&lt;/div&gt;&lt;div class="b-test"&gt;2&lt;/div&gt;&lt;div class="c-test"&gt;3&lt;/div&gt; 在这个例子中，前 2 个 div 将会被命中： 第 1 个 div，拥有 class 属性，并且值为 a，所以被命中； 第 2 个 div，拥有 class 属性，值是 a 开头并紧跟着连接符“-”，所以被命中； 伪类选择符E:link,visited,hover,active如果需要给超链接定义：访问前，鼠标悬停，当前被点击，已访问这4种伪类效果，而又没有按照一致的书写顺序，不同的浏览器可能会有不同的表现 1234a:link &#123;&#125;a:visited &#123;&#125;a:hover &#123;&#125;a:active &#123;&#125; 可靠的顺序是：l(link)ov(visited)e h(hover)a(active)te, 即用喜欢(love)和讨厌(hate)两个词来概括 See the Pen love,hate by scliuyang (@scliuyang) on CodePen. E:focus设置对象在成为输入焦点（该对象的onfocus事件发生）时的样式。 E:lang语言类选择符 123456789101112&lt;style&gt;p:lang(zh-cmn-Hans) &#123; color: #f00;&#125;p:lang(en) &#123; color: #090;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p lang="zh-cmn-Hans"&gt;大段测试文字&lt;/p&gt;&lt;p lang="en"&gt;english&lt;/p&gt; E:not匹配不含有s选择符的元素E,语法E:not(s)，括号内可以填写所有的选择符 有个列表，每个列表项都有一条底边线，但是最后一项不需要底边线123.demo li:not(:last-child) &#123; border-bottom: 1px solid #ddd;&#125; :root匹配E元素在文档的根元素,在HTML中，根元素永远是HTML 1234:root &#123; --main-color: hotpink; --pane-padding: 5px 42px;&#125; 声明全局css变量 E:first-child匹配父元素的第一个子元素E。要使该属性生效，E元素必须是某个元素的子元素，E的父元素最高是body，即E可以是body的子元素 See the Pen E:first-child by scliuyang (@scliuyang) on CodePen. E:last-child匹配父元素的最后一个子元素E，和first-child类似 E:only-child匹配父元素仅有的一个子元素E,和first-child类似。即父元素的子元素有且仅有一个E E:nth-child(n)匹配父元素的第n个子元素E，假设该子元素不是E，则选择符无效。 奇偶匹配1234567891011121314&lt;style&gt;li:nth-child(2n)&#123;color:#f00;&#125; /* 偶数 */li:nth-child(2n+1)&#123;color:#000;&#125; /* 奇数 */li:nth-child(even)&#123;color:#f00;&#125; /* 偶数 */li:nth-child(odd)&#123;color:#000;&#125; /* 奇数 */&lt;/style&gt;&lt;ul&gt; &lt;li&gt;列表项一&lt;/li&gt; &lt;li&gt;列表项二&lt;/li&gt; &lt;li&gt;列表项三&lt;/li&gt; &lt;li&gt;列表项四&lt;/li&gt;&lt;/ul&gt; See the Pen nth-child by scliuyang (@scliuyang) on CodePen. E:nth-last-child(n)匹配父元素的倒数第n个子元素E，假设该子元素不是E，则选择符无效。 E:first-of-type See the Pen E:first-of-type by scliuyang (@scliuyang) on CodePen. E:last-of-type匹配父元素下的所有E子元素中的倒数第一个。 E:only-of-type和only-child差不多，不过父元素可以有多个子元素，但其中的子元素E必须是唯一的，不能出现多个。 E:nth-of-type(n)匹配父元素的第n个子元素E。匹配的是父元素的第n个为E的子元素（被命中的不一定是第n个子元素，因为匹配的不是第n个子元素，而是第n个为E的子元素） E:nth-last-of-type(n)匹配父元素的倒数第n个子元素E。 E:empty匹配没有任何子元素（包括text节点）的元素E。 See the Pen E:empty by scliuyang (@scliuyang) on CodePen. E:checked匹配用户界面上处于选中状态的元素E。(用于input type为radio与checkbox时) E:enabled匹配用户界面上处于可用状态的元素E。 See the Pen E:enabled by scliuyang (@scliuyang) on CodePen. E:disabled匹配用户界面上处于禁用状态的元素E。 E:targetURL后面跟锚点#，指向文档内某个具体的元素。这个被链接的元素就是目标元素(target element)，:target选择器用于选取当前活动的目标元素。 See the Pen E:target by scliuyang (@scliuyang) on CodePen. 伪对象选择符E::first-letter设置对象内的第一个字符的样式。此伪对象仅作用于块对象。内联对象要使用该伪对象，必须先将其设置为块级对象。 See the Pen E::first-letter by scliuyang (@scliuyang) on CodePen. E:first-line设置对象内的第一行的样式。 E::before，E::after设置在对象前（依据对象树的逻辑结构）发生的内容。用来和content属性一起使用，并且必须定义content属性这个属性常用来实现一些ui特效或者动画效果，可以减少dom元素的数量。 E::placeholder设置对象文字占位符的样式。注意加上浏览器前缀 E::selection设置对象被选择时的样式。 需要注意的是，::selection只能定义被选择时的background-color，color及text-shadow See the Pen E::selection by scliuyang (@scliuyang) on CodePen. 选择器优先级 编号 权重 选择器或样式 1 1000 内联样式 2 100 ID选择器：#id{…} 3 10 类选择器，伪类选择器，属性选择器：.class{…}、:hover{…}、[arrtibute=value] 4 1 标签选择器，伪元素选择器：div{…}、::after{…} 5 0 其他选择器：通配选择器(*)，子选择器(&gt;)，相邻同胞选择器(+) 6 无穷大 important See the Pen selectorPriority by liuzhaozhao828 (@liuzhaozhao) on CodePen.]]></content>
      <categories>
        <category>css basic</category>
      </categories>
      <tags>
        <tag>css基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 生命周期]]></title>
    <url>%2FBlog%2F2018%2F08%2F30%2FReact%20Life%20cycle%2F</url>
    <content type="text"><![CDATA[React 生命周期公式抽象 UI=render(data) 用户看到片的界面（UI），应该是一个纯函数（render）的执行结果,只接受数据（data）作为参数。 存函数的输出完全依赖于输入的函数，两次函数条用如果输入相同，得到的结果也绝对相同。 prop prop为property的简写，意为属性 prop是组件的对外接口，state是组件的内部状态，对外用prop，内部用state。 一个React组件通过定义自己能够接受的prop就定义了自己的对外公共接口。 每个React组件都是独自存在的模块，组件之外的一切都是外部世界，外部世界就是通过prop来和组件对话。 1&lt;SampleButton id=&quot;sample&quot; borderWidth=&#123;2&#125; onClick=&#123;onButtonClick&#125; style=&#123;&#123;color:&quot;red&quot;&#125;&#125; /&gt; HTML组件的属性都是字符串类型，而React组件的prop能支持任何一种js语言数据类型，比如数字，函数，对象。 当prop的类型不是字符串类型的时候在JSX中必须用花括号{}把prop值包住。 父组件可以通过prop给子组件传递数据，同样子组件也可以通过prop给父组件反馈数据，因为prop不限制存数据，也可以是函数，函数类型的prop等于让父组件交给了子组件一个回调函数，子组件调用此prop的时候，可以带上必要的参数，这样就可以反馈数据给父组件。 123456constructor(props) &#123; super(props); this.state = &#123; count: props.initValue || 0 &#125;&#125; propTypes 、defaultProps ( prop-types v16.0, babel-react-optimize 线上环境) 12345678910111213// propTypesimport PropTypes from &apos;prop-types&apos;;、SampleButton.propTypes = &#123; id: PropTypes.string.isRequired, borderWidth: PropTypes.number&#125;SampleButton.defaultProps=&#123; borderWidth: 0&#125;例子 prop和state的对比 prop用于定义外部接口，state用于记录内部状态； prop的赋值再外部世界实用组件时，state的赋值再组件内部； 组件不应该改变prop的值，而state存在的目的就是让组件来改变的； 组件的生命周期装载过程当组件第一次被渲染的时候，一次调用这些函数。 constructor组件自己的构造函数，可用于初始化state，绑定this环境等 getInitialState &amp; getDefaultProps只有React.createClass创造的组件会有，用于初始化state和给props初始值 componentWillMount在调用render函数之前调用，这里的所有事情都可以提前到constructor中做 render一个React组件可以忽略其他所有函数都不实现，但是一定要实现render函数，因为所有React组件的父类React.Component类对其他生命周期函数都有默认实现。 render 函数并不做实际的渲染动作，它只是返回一个JSX描述的结果，最终由React 来操作渲染过程。componentDidMount在调用render函数之后调用，注意点： render函数调用完后，不会立刻调用componentDidMount，它的触发点在render已经引发了渲染，组件已经被装载到DOM数上后。 例子 不同于componentWillMount可以在服务器和浏览器端被调用，componentDidMount只能在浏览器端被调用。这点在同构的时候会用到，同时也提供给开发者一个很好的位置去做只有浏览器才做的逻辑，比如通过ALAX获取数据用来填充组件内容。 有时候React需要和其他UI库配合使用，比如jQuery,比如d3.js等，因为DOM已经存在，事件函数已设置好，所以可以在这一步进行调用。更新过程componentWillReceiveProps 只要是父组件的render函数被调用，不管传递的porps有没有改变，都会触发子组件的componentWillReceiveProps。 注意子组件内部的this.setState方法不会触发这个函数，因为这个函数是根据新的props（也就是参数nextProps）来计算是不是要更新state。 例子 shouldComponentUpdata（nextProps,nextState） 此函数决定了一个组件什么时候不需要渲染，shouldComponentUpdata返回一个布尔值，告诉React库这个组件在这次更新中是否要继续。 恰当的使用shouldComponentUpdata能够大大提高React组件的性能。 如果不写，会继承React.Component中的默认实现方式，也就是简单的返回true。 例子扩展：React.PureComponentReact.PureComponent通过浅的prop和状态比较来实现shouldComponentUpdate() 在将来，React会将shouldComponentUpdate()视为提示而不是严格的指令，并且返回false仍然可能导致组件的重新呈现。componentWillUpdaterendercomponentDidUpdate 如果组件的shouldComponentUpdata返回true，接下来就会依次调用这三个函数。 与装载不同的是，这一对函数的Did函数（componentDidUpdate）并不是只在浏览器端执行。 在React组件更新时，原有内容被重制，所以用到的UI库（比如jQuery）需要在componentDidUpdate后再次调用jQuery代码。 卸载过程componentWillUnmount当React组件需要从DOM树上删掉之前，对应的componentWillUnmount函数会被调用，移除多余的DOM元素，避免内存泄漏。 React v16.3新生命周期开启异步渲染新引入的两个生命周期函数 getDerivedStateFromProps，getSnapshotBeforeUpdate 以及在未来 v17.0 版本中即将被移除的三个生命周期函数 componentWillMount，componentWillReceiveProps，componentWillUpdate . 装载 constructor() static getDerivedStateFromProps() render() componentDidMount() 移除 componentWillMount()更新 static getDerivedStateFromProps() shouldComponentUpdate() render() getSnapshotBeforeUpdate() componentDidUpdate() 移除 componentWillUpdate() componentWillReceiveProps()getDerivedStateFromProps(nextProps, prevState)getDerivedStateFromProps在调用render方法之前调用，无论是在初始安装还是后续更新。它应该返回一个更新状态的对象，或者返回null以不更新任何状态。 getSnapshotBeforeUpdate(prevProps, prevState)getSnapshotBeforeUpdate()在最近呈现的输出被提交到例如DOM之前调用。它使您的组件可以在可能更改之前从DOM捕获一些信息（例如滚动位置）。此生命周期返回的任何值都将作为参数传递给componentDidUpdate()。12345678910111213141516171819202122232425262728293031323334可能出现在需要以特殊方式处理滚动位置的聊天线程等UI中。比如jtalkclass ScrollingList extends React.Component &#123; constructor(props) &#123; super(props); this.listRef = React.createRef(); &#125; getSnapshotBeforeUpdate(prevProps, prevState) &#123; // 我们是否在列表中添加新项目? // 捕获滚动位置，以便我们稍后调整滚动. if (prevProps.list.length &lt; this.props.list.length) &#123; const list = this.listRef.current; return list.scrollHeight - list.scrollTop; &#125; return null; &#125; componentDidUpdate(prevProps, prevState, snapshot) &#123; // 如果snapshot有返回值，我们就是添加了新项目. // 调整滚动，以便这些新项目不会将旧项目推出视图. // (这里的snapshot是从getSnapshotBeforeUpdate中返回的值) if (snapshot !== null) &#123; const list = this.listRef.current; list.scrollTop = list.scrollHeight - snapshot; &#125; &#125; render() &#123; return ( &lt;div ref=&#123;this.listRef&#125;&gt;&#123;/* ...contents... */&#125;&lt;/div&gt; ); &#125;&#125; 在上面的例子中，重要的是读取scrollHeight属性，getSnapshotBeforeUpdate因为“渲染”阶段生命周期（如render）和“提交”阶段生命周期（如getSnapshotBeforeUpdate和componentDidUpdate）之间可能存在延迟。 错误处理componentDidCatch(error, info)错误边界是React组件，它们在其子组件树中的任何位置捕获JavaScript错误，记录这些错误，并显示回退UI而不是崩溃的组件树。错误边界在渲染期间，生命周期方法以及它们下面的整个树的构造函数中捕获错误。 123456789101112131415161718192021class ErrorBoundary extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; hasError: false &#125;; &#125; componentDidCatch(error, info) &#123; // Display fallback UI this.setState(&#123; hasError: true &#125;); // You can also log the error to an error reporting service logErrorToMyService(error, info); &#125; render() &#123; if (this.state.hasError) &#123; // You can render any custom fallback UI return &lt;h1&gt;Something went wrong.&lt;/h1&gt;; &#125; return this.props.children; &#125;&#125;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修饰器（装饰器，注解）]]></title>
    <url>%2FBlog%2F2018%2F08%2F30%2FDecorator%2F</url>
    <content type="text"><![CDATA[修饰器（装饰器，注解）1.类的修饰12345678910@testableclass MyTestableClass &#123; // ...&#125;function testable(target) &#123; target.isTestable = true;&#125;MyTestableClass.isTestable // true 上面代码中，@testable就是一个修饰器。它修改了MyTestableClass这个类的行为，为它加上了静态属性isTestable。testable函数的参数target是MyTestableClass类本身。 1234567也就是说，修饰器是一个对类进行处理的函数。修饰器函数的第一个参数，就是所要修饰的目标类。function testable(target) &#123; // ...&#125;testable函数的参数target，就是会被修饰的类。 如果觉得一个参数不够用，可以在修饰器外面再封装一层函数。 12345678910111213function testable(isTestable) &#123; return function(target) &#123; target.isTestable = isTestable; &#125;&#125;@testable(true)class MyTestableClass &#123;&#125;MyTestableClass.isTestable // true@testable(false)class MyClass &#123;&#125;MyClass.isTestable // false react-redux @connect 装饰器实际开发中，React 与 Redux 库结合使用时，常常需要写成下面这样。12class MyReactComponent extends React.Component &#123;&#125;export default connect(mapStateToProps, mapDispatchToProps)(MyReactComponent); 有了装饰器，就可以改写上面的代码。 12@connect(mapStateToProps, mapDispatchToProps)export default class MyReactComponent extends React.Component &#123;&#125; 相对来说，后一种写法看上去更容易理解。 2.方法的修饰修饰器不仅可以修饰类，还可以修饰类的属性。 12345class Person &#123; @readonly name() &#123; return `$&#123;this.first&#125; $&#123;this.last&#125;` &#125;&#125;修饰器readonly用来修饰“类”的name方法。 修饰器函数readonly一共可以接受三个参数。 123456789101112131415function readonly(target, name, descriptor)&#123; // descriptor对象原来的值如下 // &#123; // value: specifiedFunction, // enumerable: false, // configurable: true, // writable: true // &#125;; descriptor.writable = false; return descriptor;&#125;readonly(Person.prototype, &apos;name&apos;, descriptor);// 类似于Object.defineProperty(Person.prototype, &apos;name&apos;, descriptor); 修饰器第一个参数是类的原型对象，上例是Person.prototype，修饰器的本意是要“修饰”类的实例，但是这个时候实例还没生成，所以只能去修饰原型（这不同于类的修饰，那种情况时target参数指的是类本身）；第二个参数是所要修饰的属性名，第三个参数是该属性的描述对象。 例1：修改属性描述对象的enumerable属性，使得该属性不可遍历。 123456789class Person &#123; @nonenumerable get kidCount() &#123; return this.children.length; &#125;&#125;function nonenumerable(target, name, descriptor) &#123; descriptor.enumerable = false; return descriptor;&#125; 例2：下面的@log修饰器，可以起到输出日志的作用。 12345678910111213141516171819202122class Math &#123; @log add(a, b) &#123; return a + b; &#125;&#125;function log(target, name, descriptor) &#123; var oldValue = descriptor.value; descriptor.value = function() &#123; console.log(`Calling $&#123;name&#125; with`, arguments); return oldValue.apply(this, arguments); &#125;; return descriptor;&#125;const math = new Math();// passed parameters should get logged nowmath.add(2, 4); 上面代码中，@log修饰器的作用就是在执行原始的操作之前，执行一次console.log，从而达到输出日志的目的。 另外，修饰器有==注释==的作用。 123456@testableclass Person &#123; @readonly @nonenumerable name() &#123; return `$&#123;this.first&#125; $&#123;this.last&#125;` &#125;&#125; 从上面代码中，我们一眼就能看出，Person类是可测试的，而name方法是只读和不可枚举的。 常见的修饰器库core-decorators.js（1）@autobindautobind修饰器使得方法中的this对象，绑定原始对象。 1234567891011121314import &#123; autobind &#125; from &apos;core-decorators&apos;;class Person &#123; @autobind getPerson() &#123; return this; &#125;&#125;let person = new Person();let getPerson = person.getPerson;getPerson() === person;// true （2）@readonly12345678910import &#123; readonly &#125; from &apos;core-decorators&apos;;class Meal &#123; @readonly entree = &apos;steak&apos;;&#125;var dinner = new Meal();dinner.entree = &apos;salmon&apos;;// Cannot assign to read only property &apos;entree&apos; of [object Object] （3）@overrideoverride修饰器检查子类的方法，是否正确覆盖了父类的同名方法，如果不正确会报错。 （4）@deprecate (别名@deprecated)deprecate或deprecated修饰器在控制台显示一条警告，表示该方法将废除。 1234567891011121314151617181920212223242526import &#123; deprecate &#125; from &apos;core-decorators&apos;;class Person &#123; @deprecate facepalm() &#123;&#125; @deprecate(&apos;We stopped facepalming&apos;) facepalmHard() &#123;&#125; @deprecate(&apos;We stopped facepalming&apos;, &#123; url: &apos;http://knowyourmeme.com/memes/facepalm&apos; &#125;) facepalmHarder() &#123;&#125;&#125;let person = new Person();person.facepalm();// DEPRECATION Person#facepalm: This function will be removed in future versions.person.facepalmHard();// DEPRECATION Person#facepalmHard: We stopped facepalmingperson.facepalmHarder();// DEPRECATION Person#facepalmHarder: We stopped facepalming//// See http://knowyourmeme.com/memes/facepalm for more details.// Postal.js我们可以使用修饰器，使得对象的方法被调用时，自动发出一个事件。 1234567891011121314151617181920const postal = require(&quot;postal/lib/postal.lodash&quot;);export default function publish(topic, channel) &#123; const channelName = channel || &apos;/&apos;; const msgChannel = postal.channel(channelName); msgChannel.subscribe(topic, v =&gt; &#123; console.log(&apos;频道: &apos;, channelName); console.log(&apos;事件: &apos;, topic); console.log(&apos;数据: &apos;, v); &#125;); return function(target, name, descriptor) &#123; const fn = descriptor.value; descriptor.value = function() &#123; let value = fn.apply(this, arguments); msgChannel.publish(topic, value); &#125;; &#125;;&#125; 上面代码定义了一个名为publish的修饰器，它通过改写descriptor.value，使得原方法被调用时，会自动发出一个事件。 123456789101112131415161718// index.jsimport publish from &apos;./publish&apos;;class FooComponent &#123; @publish(&apos;foo.some.message&apos;, &apos;component&apos;) someMethod() &#123; return &#123; my: &apos;data&apos; &#125;; &#125; @publish(&apos;foo.some.other&apos;) anotherMethod() &#123; // ... &#125;&#125;let foo = new FooComponent();foo.someMethod();foo.anotherMethod(); Mixin在修饰器的基础上，可以实现Mixin模式。所谓Mixin模式，就是对象继承的一种替代方案，中文译为“混入”（mix in），意为在一个对象之中混入另外一个对象的方法 12345678910const Foo = &#123; foo() &#123; console.log(&apos;foo&apos;) &#125;&#125;;class MyClass &#123;&#125;Object.assign(MyClass.prototype, Foo);let obj = new MyClass();obj.foo() // &apos;foo&apos; 上面代码之中，对象Foo有一个foo方法，通过Object.assign方法，可以将foo方法“混入”MyClass类，导致MyClass的实例obj对象都具有foo方法。这就是“混入”模式的一个简单实现。 我们部署一个通用脚本mixins.js，将 Mixin 写成一个修饰器。12345export function mixins(...list) &#123; return function (target) &#123; Object.assign(target.prototype, ...list); &#125;;&#125; 然后，就可以使用上面这个修饰器，为类“混入”各种方法。 1234567891011import &#123; mixins &#125; from &apos;./mixins&apos;;const Foo = &#123; foo() &#123; console.log(&apos;foo&apos;) &#125;&#125;;@mixins(Foo)class MyClass &#123;&#125;let obj = new MyClass();obj.foo() // &quot;foo&quot; 通过mixins这个修饰器，实现了在MyClass类上面“混入”Foo对象的foo方法。 TraitTrait 也是一种修饰器，效果与 Mixin 类似，但是提供更多功能，比如防止同名方法的冲突、排除混入某些方法、为混入的方法起别名等等。 以traits-decorator这个第三方模块作为例子。这个模块提供的traits修饰器，不仅可以接受对象，还可以接受 ES6 类作为参数。 12345678910111213141516import &#123; traits &#125; from &apos;traits-decorator&apos;;class TFoo &#123; foo() &#123; console.log(&apos;foo&apos;) &#125;&#125;const TBar = &#123; bar() &#123; console.log(&apos;bar&apos;) &#125;&#125;;@traits(TFoo, TBar)class MyClass &#123; &#125;let obj = new MyClass();obj.foo() // fooobj.bar() // bar 上面代码中，通过traits修饰器，在MyClass类上面“混入”了TFoo类的foo方法和TBar对象的bar方法。 Trait 不允许“混入”同名方法。一种解决方法是排除TBar的foo方法。 1234567891011121314151617import &#123; traits, excludes &#125; from &apos;traits-decorator&apos;;class TFoo &#123; foo() &#123; console.log(&apos;foo&apos;) &#125;&#125;const TBar = &#123; bar() &#123; console.log(&apos;bar&apos;) &#125;, foo() &#123; console.log(&apos;foo&apos;) &#125;&#125;;@traits(TFoo, TBar::excludes(&apos;foo&apos;))class MyClass &#123; &#125;let obj = new MyClass();obj.foo() // fooobj.bar() // bar 另一种方法是为TBar的foo方法起一个别名。123456789101112131415161718import &#123; traits, alias &#125; from &apos;traits-decorator&apos;;class TFoo &#123; foo() &#123; console.log(&apos;foo&apos;) &#125;&#125;const TBar = &#123; bar() &#123; console.log(&apos;bar&apos;) &#125;, foo() &#123; console.log(&apos;foo&apos;) &#125;&#125;;@traits(TFoo, TBar::alias(&#123;foo: &apos;aliasFoo&apos;&#125;))class MyClass &#123; &#125;let obj = new MyClass();obj.foo() // fooobj.aliasFoo() // fooobj.bar() // bar alias和excludes方法，可以结合起来使用。 12345@traits(TExample::excludes(&apos;foo&apos;,&apos;bar&apos;)::alias(&#123;baz:&apos;exampleBaz&apos;&#125;))class MyClass &#123;&#125;或者@traits(TExample::as(&#123;excludes:[&apos;foo&apos;, &apos;bar&apos;], alias: &#123;baz: &apos;exampleBaz&apos;&#125;&#125;))class MyClass &#123;&#125; 安装方式12345$ npm install babel-core babel-plugin-transform-decorators然后，设置配置文件.babelrc&#123; &quot;plugins&quot;: [&quot;transform-decorators&quot;]&#125;]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>修饰器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css属性:颜色(color)与字体(font)]]></title>
    <url>%2FBlog%2F2018%2F08%2F21%2FcolorFont%2F</url>
    <content type="text"><![CDATA[颜色 color检索或设置对象的文本颜色。无默认值默认值：由user agent决定 适用于：所有元素 继承性：有 动画性：是 计算值：指定值 取值: color：指定颜色 说明1.可以使用Color Name(颜色名称), HEX, RGB, RGBA, HSL, HSLA, transparent来指定color。 Color Name(颜色名称)：red,blue; HEX（十六进制）：#RRGGBB；#ff0000,#ffffff; RGB: RGB(R,G,B); rgb(255,0,0); RGBA:此色彩模式与RGB相同，只是在RGB模式上新增了Alpha透明度rgb(255,0,0,0.5)； HSL、HSLA:色调（0-360），饱和度（0%-100%），亮度（0-100%）； transparent：transparent是全透明黑色(black)的速记法，即一个类似rgba(0,0,0,0)这样的值。 See the Pen MqYgEv by vivizhou0596 (@vivizhou0596) on CodePen. 2.注意，用颜色名称指定color可能不被一些浏览器接受。 3.color属性值被间接用来提供一个中间值currentColor以供其他接受颜色值的属性使用。 See the Pen yxyBZp by vivizhou0596 (@vivizhou0596) on CodePen. 字体 fontfontfont 简写属性在一个声明中设置所有字体属性。 复合属性：[ [font-style||font-variant||font-weight||font-stretch]?font-size[ /line-height]?font-family] | caption | icon | menu | message-box | small-caption | status-bar 取值： font-style：指定文本字体样式 font-variant：指定文本是否为小型的大写字母 font-weight：指定文本字体的粗细 font-stretch：指定文本字体拉伸变形 font-size：指定文本字体尺寸 line-height：指定文本字体的行高 font-family：指定文本使用某个字体或字体序列 caption：使用有标题的系统控件的文本字体（如按钮，菜单等）（CSS2） icon：使用图标标签的字体（CSS2） menu：使用菜单的字体（CSS2） message-box：使用信息对话框的文本字体（CSS2） small-caption：使用小控件的字体（CSS2） status-bar：使用窗口状态栏的字体（CSS2） 注：使用font属性参数必须按照如上的排列顺序，且font-size和font-family是不可忽略的。每个参数仅允许有一个值。忽略的将使用其参数对应的独立属性的默认值。 See the Pen GXgRym by vivizhou0596 (@vivizhou0596) on CodePen. font-style 定义字体的风格 normal：指定文本字体样式为正常的字体 italic：指定文本字体样式为斜体。对于没有设计斜体的特殊字体，如果要使用斜体外观将应用oblique oblique：指定文本字体样式为倾斜的字体。人为的使文字倾斜，而不是去选取字体中的斜体字 font-variant把段落设置为小型大写字母字体 normal：正常的字体 small-caps：小型的大写字母字体 font-weight设置文本的粗细 normal：正常的字体。相当于数字值400 bold：粗体。相当于数字值700。 bolder：定义比继承值更重的值 lighter：定义比继承值更轻的值 ：用数字表示文本字体粗细。取值范围：100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900 font-size可设置字体的尺寸 absolute-size：根据对象字号进行调节。以 medium 作为基础参照，xx-small相当于medium 3/5 (h6)，x-small: 3/4，small: 8/9 (h5)，medium: 1 (h4)，large: 6/5 (h3)，x-large: 3/2 (h2)，xx-large: 2/1 (h1)， relative-size：相对于父对像中字号进行相对调节。使用成比例的em单位计算。 length：用长度值指定文字大小。不允许负值。 percentage：用百分比指定文字大小。其百分比取值是基于父对象中字体的尺寸。不允许负值。 font-family规定元素的字体系列 family-name：字体名称。按优先顺序排列。以逗号隔开。如果字体名称包含空格或中文，则应使用引号括起 generic-family：字体序列名称。font-family 可以把多个字体名称作为一个“回退”系统来保存。如果浏览器不支持第一个字体，则会尝试下一个。也就是说，font-family 属性的值是用于某个元素的字体族名称或/及类族名称的一个优先表。浏览器会使用它可识别的第一个值。 有两种类型的字体系列名称： 字体名称：具体字体的名称，比如：”times”、”courier”、”arial”,”宋体”。 通常字体系列名称：比如：”serif”（笔画两端有脚）、”sans-serif”（笔画两端没有脚）、”cursive”、”fantasy”、”monospace”（所有字符宽度都一样） 提示： 1.使用逗号分割每个值，并始终提供一个类族名称作为最后的选择。 2.所有的表单元素都是无法继承body的字体属性的，所以平常的只在body后加入字体是不行的，需要为用的表单元素单独设计字体 多列通过 CSS3，您能够创建多个列来对文本进行布局 - 就像报纸那样！ 常用属性： 1.column-count 属性规定元素应该被分隔的列数；2.column-gap 属性规定列之间的间隔；3.column-rule 属性设置列之间的宽度、样式和颜色规则。 See the Pen GXggeP by vivizhou0596 (@vivizhou0596) on CodePen.]]></content>
      <categories>
        <category>css basic</category>
      </categories>
      <tags>
        <tag>css基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css属性:文本(Text)]]></title>
    <url>%2FBlog%2F2018%2F08%2F16%2Ftext%2F</url>
    <content type="text"><![CDATA[参考链接： css.doyoe.com css2.1中文版 MDN 一.text-transformtext-transform 属性指定如何将元素的文本进行大小写变形。它可以用于使文本显示为全大写或全小写，也可单独对每一个单词进行操作。 1234567初始值 none适用元素 all elements. It also applies to ::first-letter and ::first-line.是否是继承属性 yes适用媒体 visual计算值 as specifiedAnimation type discrete正规顺序 the unique non-ambiguous order defined by the formal grammar 语法1234567891011/* Keyword values */text-transform: capitalize;text-transform: uppercase;text-transform: lowercase;text-transform: none;text-transform: full-width;/* Global values */text-transform: inherit;text-transform: initial;text-transform: unset; capitalize: 将文本中的每个单词以大写字母开头(只会对每个单词第一个字母做变形，对其他字母保持不变) uppercase: 将文本中的所有字符变为大写 lowercase： 将文本中的所有字符变为小写 none： 默认值，不对文本进行大小写转换 full-width： 将所有字符转换成fullwidth形式。如果字符没有相应的fullwidth形式，将保留原样。这个值通常用于排版拉丁字符和数字等表意符号。(全角) text-transform代码演示 二、white-spacewhite-space 属性是用来设置如何处理元素中的空白。 1234567初始值 normal适用元素 all elements是否是继承属性 yes适用媒体 visual计算值 as specifiedAnimation type discrete正规顺序 the unique non-ambiguous order defined by the formal grammar 语法 1234567white-space: normalwhite-space: nowrapwhite-space: prewhite-space: pre-wrapwhite-space: pre-linewhite-space: inherit normal 默认值,连续的空白符会被合并，换行符会被当作空白符来处理。填充line盒子时，必要的话会换行。 nowrap 和 normal 一样，连续的空白符会被合并。但文本内的换行无效。 pre 连续的空白符会被保留。在遇到换行符或者元素时才会换行。 pre-wrap 连续的空白符会被保留。在遇到换行符或者元素，或者需要为了填充line盒子时才会换行。 pre-line 连续的空白符会被合并。在遇到换行符或者元素，或者需要为了填充line盒子时会换行。 — 换行符 空格和制表符 文字转行 normal 合并 合并 转行 nowrap 合并 合并 不转行 pre 保留 保留 不转行 pre-wrap 保留 保留 转行 pre-line 保留 合并 转行 white-space代码示例 三、tab-sizetab-size 定义元素内容中制表符的长度。(a tab (U+0009) character),只有当white-space的属性值为：pre | pre-wrap时，该属性的定义才有效 1234567初始值 8适用元素 block containers是否是继承属性 yes适用媒体 visual计算值 the specified integer or an absolute lengthAnimation type a length正规顺序 the unique non-ambiguous order defined by the formal grammar 123456789101112/* &lt;integer&gt; values */tab-size: 4;tab-size: 0;/* &lt;length&gt; values */tab-size: 10px;tab-size: 2em;/* Global values */tab-size: inherit;tab-size: initial;tab-size: unset; tab-size代码示例 四、word-breakword-break定义元素内容文本的字间与字符间的换行行为 1234567初始值 normal适用元素 all elements是否是继承属性 yes适用媒体 visual计算值 as specifiedAnimation type discrete正规顺序 the unique non-ambiguous order defined by the formal grammar 12345678word-break: normal word-break: break-all word-break: keep-all/* Global values */word-break: inherit;word-break: initial;word-break: unset; normal使用默认的断行规则。 break-all对于non-CJK (CJK 指中文/日文/韩文) 文本，可在任意字符间断行。 keep-allCJK 文本不断行。 Non-CJK 文本表现同 normal。 break-word与break-all相同，不同的地方在于它要求一个没有断行破发点的词必须保持为一个整体单位。这与word-wrap的break-word值效果相同 word-break代码示例 五、word-wrap/overflow-wrap 注：word-wrap 属性原本属于微软的一个私有属性，在 CSS3 现在的文本规范草案中已经被重名为 overflow-wrap 。 word-wrap 现在被当作 overflow-wrap 的 “别名”。 稳定的谷歌 Chrome 和 Opera 浏览器版本支持这种新语法。 1234567初始值 normal适用元素 all elements是否是继承属性 yes适用媒体 visual计算值 as specifiedAnimation type discrete正规顺序 the unique non-ambiguous order defined by the formal grammar 12345678/* Keyword values */overflow-wrap: normal;overflow-wrap: break-word;/* Global values */overflow-wrap: inherit;overflow-wrap: initial;overflow-wrap: unset; normal表示在正常的单词结束处换行。 break-word表示如果行内没有多余的地方容纳该单词到结尾，则那些正常的不能被被分割的单词会被强制分割换行。 word-wrap/overflow-wrap代码示例 六、text-aligntext-align CSS属性定义行内内容（例如文字）如何相对它的块父元素对齐。text-align 并不控制块元素自己的对齐，只控制它的行内内容的对齐。 1234567初始值 start, or a nameless value that acts as left if direction is ltr, right if direction is rtl if start is not supported by the browser.适用元素 block containers是否是继承属性 yes适用媒体 visual计算值 as specified, except for the match-parent value which is calculated against its parent&apos;s direction value and results in a computed value of either left or rightAnimation type discrete正规顺序 order of appearance in the formal grammar of the values 语法12345678910111213141516171819202122/* Keyword values */text-align: left;text-align: right;text-align: center;text-align: justify;text-align: justify-all;text-align: start;text-align: end;text-align: match-parent;/* Character-based alignment in a table column */text-align: &quot;.&quot;;text-align: &quot;.&quot; center;/* Block alignment values (Non-standard syntax) */text-align: -moz-center;text-align: -webkit-center;/* Global values */text-align: inherit;text-align: initial;text-align: unset; start如果内容方向是左至右，则等于left，反之则为right。 end如果内容方向是左至右，则等于right，反之则为left。 left行内内容向左侧边对齐。 right行内内容向右侧边对齐。 center行内内容居中。 &lt;string&gt;第一个出现的该（单字符）字符串被用来对齐。跟随的关键字定义对齐的方向。例如，可用于让数字值根据小数点对齐。 justify文字向两侧对齐，对最后一行无效。 justify-all和justify一致，但是强制使最后一行两端对齐。 match-parent和inherit类似，区别在于start和end的值根据父元素的direction确定，并被替换为恰当的left或right。 text-align示例 七、text-align-lasttext-align-last 描述的是一段文本中最后一行在被强制换行之前的对齐规则。 注意：IE浏览器下，如果text-align-last要生效，必须先定义text-align为justify； 1234567初始值 auto适用元素 block containers是否是继承属性 yes适用媒体 visual计算值 as specifiedAnimation type discrete正规顺序 the unique non-ambiguous order defined by the formal grammar 12345678910111213/* Keyword values */text-align-last: auto;text-align-last: start;text-align-last: end;text-align-last: left;text-align-last: right;text-align-last: center;text-align-last: justify;/* Global values */text-align-last: inherit;text-align-last: initial;text-align-last: unset; auto每一行的对齐规则由 text-align 的值来确定，当 text-align 的值是 justify，text-align-last 的表现和设置了 start 的表现是一样的，即如果文本的展示方向是从左到右，则最后一行左侧对齐与内容盒子。经测试，当 text-align 的值为 right，并且 text-align-last 设置为 auto 时，文本最后一行的对齐方式相当于 text-align-last 被设置为 right 时的效果。即 text-align-last 设置为 auto 后的表现跟 text-align 的设置有关。 start与 direction 的设置有关。如果文本展示方向是从左到右，起点在左侧，则是左对齐；如果文本展示方向是从右到左，起点在右侧，则是右对齐。如果没有设置 direction ，则按照浏览器文本的默认显示方向来确定。 end与 direction 的设置有关。如果文本展示方向是从左到右，末尾在右侧，则是右对齐；如果文本展示方向是从右到左，末尾在左侧，则是左对齐。如果没有设置 direction ，则按照浏览器文本的默认显示方向来确定。 left最后一行文字与内容盒子的左侧对齐 right最后一行文字与内容盒子的右侧对齐 center最后一行文字与内容盒子居中对齐 justify最后一行文字的开头语内容盒子的左侧对齐，末尾与右侧对齐。 text-align-last示例 八、text-justifytext-justify定义的是当文本的 text-align 属性被设置为 :justify 时的齐行方法。 1234567初始值 auto适用元素 inline-level and table-cell elements是否是继承属性 yes适用媒体 visual计算值 as specifiedAnimation type discrete正规顺序 the unique non-ambiguous order defined by the formal grammar auto：允许浏览器用户代理确定使用的两端对齐法则。 none：禁止两端对齐。 inter-word：通过增加字之间的空格对齐文本。该行为是对齐所有文本行最快的方法，它的两端对齐行为对段落的最后一行无效。 inter-ideograph：为表意字文本提供完全两端对齐，增加或减少表意字和词间的空格。 inter-cluster：调整文本无词间空格的行。这种模式的调整是用于优化亚洲语言文档的 distribute：通过增加或减少字或字母之间的空格对齐文本，适用于东亚文档，尤其是泰国。 kashida：通过拉长选定点的字符调整文本。这种调整模式是特别为阿拉伯脚本语言提供的。需要IE5.5+支持 inter-character通过在文本中的字符之间添加空间来实现行对齐（这将会改变 letter-spacing 的值），比如日语就是最适合使用这个属性的语言。 text-justify示例 九、word-spacingword-spacing属性用于声明标签和单词直接的间距行为。 12345678初始值 normal适用元素 all elements. It also applies to ::first-letter and ::first-line.是否是继承属性 yesPercentages refer to the width of the affected glyph适用媒体 visual计算值 an optimum, minimum, and maximum value, each consisting of either an absolute length, a percentage, or the keyword normalAnimation type a length正规顺序 the unique non-ambiguous order defined by the formal grammar 123456789101112131415/* Keyword value */word-spacing: normal;/* &lt;length&gt; values */word-spacing: 3px;word-spacing: 0.3em;/* &lt;percentage&gt; values */word-spacing: 50%;word-spacing: 200%;/* Global values */word-spacing: inherit;word-spacing: initial;word-spacing: unset; normal初始值，正常的单词间距，由当前字体和/或浏览器定义。 &lt;length&gt;通过指定具体的额外间距来增加字体的单词间距。 &lt;percentage&gt;通过指定受影响字符的宽度的百分比的方式来增加的间距。 word-spacing示例 十、letter-spacingletter-spacing属性明确了文字字母的间距行为。 1234567初始值 normal适用元素 all elements. It also applies to ::first-letter and ::first-line.是否是继承属性 yes适用媒体 visual计算值 an optimum value consisting of either an absolute length or the keyword normalAnimation type a length正规顺序 the unique non-ambiguous order defined by the formal grammar 1234567letter-spacing: normal;letter-spacing: 0.3em;letter-spacing: 3px;letter-spacing: .3px;letter-spacing: inherit; normal(默认值) 此间距是按照当前字体的正常间距确定的。 用户代理根据此属性来确定文字的默认对齐方式。等同于间距 0。 &lt;length&gt;指定文字间的间距以替代默认间距。可以是负值，但有可能会出现 implementation 限制。用户代理不会在此基础上进一步增加或缩减间距来对齐文字。 letter-spacing示例 合理使用：一个很大的正或负的letter-spacing值会将应用这个样式的单词边为不可读的。给文本letter-spacing属性应用了一个很大的正值，字母之间的距离会很远，以至于文本中的单词将显示为一系列单独的，无有任何关联的字母。给文本letter-spacing属性应用了一个很大的负值，字母将会互相重叠到一个点，在这个点上单词可能无法识别了。 一个最佳的易辨认的字母间距（letter-spacing）必须根据具体情况来确定，因为不同的字体系列具有不同的字符宽度。没有任何一个值可以确保所有字体系列自动保持它们的可读性。 十一、text-indenttext-indent 属性 规定了 一个元素 首行 文本内容之前应该有多少水平空格。水平空格是块级包含元素的内容盒子的左边(对于从右向左布局来说是右边). 12345678初始值 0适用元素 block containers是否是继承属性 yesPercentages refer to the width of the containing block适用媒体 visual计算值 the percentage as specified or the absolute length, plus any keywords as specifiedAnimation type a length, percentage or calc();正规顺序 The length or percentage before the keywords, if both are present. If several keywords are present, they appear in the same order as their appearance in the formal grammar. 1234567891011121314151617/* &lt;length&gt; values */text-indent: 3mm;text-indent: 40px;/* &lt;percentage&gt; value relative to the containing block width */text-indent: 15%;/* Keyword values */text-indent: 5em each-line;text-indent: 5em hanging;text-indent: 5em hanging each-line;/* Global values */text-indent: inherit;text-indent: initial;text-indent: unset; &lt;length&gt;使用固定的值来指定文本的缩进。允许使用负值。 &lt;percentage&gt;使用包含块宽度的百分比作为缩进。 each-line（css3）文本缩进会影响第一行，以及使用强制断行后的第一行。 hanging（css3）该值会对所有的行进行反转缩进：除了第一行之外的所有的行都会被缩进，看起来就像第一行设置了一个负的缩进值。 注：each-line和hanging均为实验性功能 chrome开启: chrome://flags/#enable-experimental-web-platform-features text-indent代码示例 十二、vertical-alignvertical-align属性用来指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。 12345678初始值 baseline适用元素 inline-level and table-cell elements. It also applies to ::first-letter and ::first-line.是否是继承属性 否Percentages refer to the line-height of the element itself适用媒体 visual计算值 for percentage and length values, the absolute length, otherwise the keyword as specifiedAnimation type a length正规顺序 the unique non-ambiguous order defined by the formal grammar 123456789101112131415161718192021/* keyword values */vertical-align: baseline;vertical-align: sub;vertical-align: super;vertical-align: text-top;vertical-align: text-bottom;vertical-align: middle;vertical-align: top;vertical-align: bottom;/* &lt;length&gt; values */vertical-align: 10em;vertical-align: 4px;/* &lt;percentage&gt; values */vertical-align: 20%;/* Global values */vertical-align: inherit;vertical-align: initial;vertical-align: unset; 取值 (对于行内(inline)元素)下列值只对父级行内元素或者一个父级块容器元素的strut有效 在下面的定义中，对于行内非替换元素，用于对齐的盒是那个高度为’line-height’（包括该盒的字形和两边的半行距，见上文）的盒。对于其它所有元素，用于对齐的盒都是外边距框（margin box） baseline默认。把盒的基线与父级盒的基线对齐。如果该盒没有基线，就把下外边距边界和父级的基线对齐。 sub把该盒的基线降低到合适的位置作为父级盒的下标（该值不影响该元素文本的字体大小） super把该盒的基线提升到合适的位置作为父级盒的上标（该值不影响该元素文本的字体大小） text-top把该盒的顶端和父级的内容区（content area）的顶端对齐 text-bottom把该盒的底端和父级的内容区的底端对齐 middle把该盒的垂直中点与父级盒的基线加上父级的半x-height对齐 &lt;length&gt;把该盒提升（正值）或者降低（负值）这个距离。值’0cm’表示与“基线”相同 &lt;percentage&gt;把该盒提升（正值）或者降低（负值）这个距离（’line-height’值的百分比）。值’0%’表示与“基线”相同 以下两个值是相对于整行来说的： top元素及其后代的顶端与line-box正行的顶端对齐。 bottom元素及其后代的底端与line-box整行的底端对齐。 如果元素没有基线baseline，则以它的外边距的下边缘为基线。 取值 (对于table-cell元素) baseline (and sub, super, text-top, text-bottom, &lt;length&gt;, and &lt;percentage&gt;)与同行单元格的基线对齐。 top单元格的内边距的上边缘与行的顶端对齐。 middle单元格垂直居中。 bottom单元格的内边距的下边缘与行的底端对齐。 可以取负值。 vertical-align代码示例 十四、line-heightline-height 属性用于设置多行元素的空间量，比如文本。对于块级元素，它指定元素行盒（line boxes）的最小高度。对于非替代的inline元素，它用于计算行盒（line box）的高度。 1234567Value: normal | &lt;number&gt; | &lt;length&gt; | &lt;percentage&gt; | inherit初始值: normal适用元素: 所有元素是否可继承: yesPercentages: 参考元素自身的字体大小Media: visualComputed value: 对于&lt;length&gt;和&lt;percentage&gt;是绝对的值，否则与指定值相同 1234567891011121314151617/* Keyword value */line-height: normal;/* Unitless values: use this number multipliedby the element&apos;s font size */line-height: 3.5;/* &lt;length&gt; values */line-height: 3em;/* &lt;percentage&gt; values */line-height: 34%;/* Global values */line-height: inherit;line-height: initial;line-height: unset; normal告诉用户代理根据该元素的字体把应用值设置为一个“合理的”值。该值与的含义相同。我们推荐介于1.0到1.2的“常规”应用值。计算值为’normal’ &lt;length&gt;指定的长度用来计算行框的高度。负值是非法的 &lt;number&gt;该属性的应用值为这个数字乘以该元素的字体大小。负值是非法的。计算值与指定值相同 &lt;percentage&gt;该属性的计算值为这个百分比乘以该元素的字体大小的计算值。负值是非法的 line-height代码示例 十五、text-size-justifytext-size-adjust 属性 允许我们控制将文本溢出算法应用到一些手机设备上。这个属性还没有写进标准，使用时必须加上前缀：-moz-text-size-adjust，-webkit-text-size-adjust,，和 -ms-text-size-adjust。 许多网页还没有用手机开发，智能手机浏览器和桌面浏览器渲染网页时在一些地方有不同。他们不是以设备屏幕宽度布局网页，而是用比屏幕宽一些的视窗去布局网页，通常是800到1000像素。为了将视窗上的布局映射到原始设备屏幕上，手机浏览器要么只渲染整个页面的一部分，要么将视窗缩放至原始屏幕大小。 因为缩放适配小屏幕而导致文字会变得很小，许多手机浏览器会使用文本溢出算法让文本变大而更易读。当一个包含文本的元素宽度用了100%，他的文本大小会增加直到达到一个易读的大小，但是不会修改布局。 text-size-adjust 这个属性允许开发者去除或者修改这个浏览器默认行为，因为当网页设计已经处理小屏幕的宽度问题时不需要他。 这个属性并不是标准。 你必须为每个你想要应用的浏览器加上属性前缀。 不同浏览器，这个属性有不同的行为和语法。更多的信息，请查看下面的浏览器兼容性部分。 这个属性只有在一些智能手机和平板电脑上使用。 桌面浏览器和一些平板电脑浏览器并没有一些溢出算法。 如果 -webkit-text-size-adjust 显式设置为 none, 老的基于桌面的WebKit和平板电脑浏览器，像 Chrome≤26 或者 Safari≤5, 不会忽略这个属性, 反而会阻止用户在web界面放大或缩小。# 不是所有的浏览器都支持这个属性使用百分比值(例如 Webkit 和 Trident , 但是 Gecko不支持). 检查下面浏览器兼容的部分查看更多的信息。 12345678910111213/* 文本不会放大 */text-size-adjust: none;/* 文本可能会被放大 */text-size-adjust: auto;/* 文本固定为原大小的80% */text-size-adjust: 80%;/* 全局的值 */text-size-adjust: inherit;text-size-adjust: initial;text-size-adjust: unset; none禁用浏览器的文本溢出算法。在老的基于webkit内核的桌面端浏览器，这将阻止用户将网页放大或缩小。 auto启用 浏览器的文本溢出算法。该值用于取消先前使用CSS设置的none。 &lt;percentage&gt;启用 浏览器的文本溢出算法，具体用一个百分数来确定文本放大范围。 text-size-justify代码示例]]></content>
      <categories>
        <category>css basic</category>
      </categories>
      <tags>
        <tag>css基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[line-height 爱我你怕了吗]]></title>
    <url>%2FBlog%2F2018%2F08%2F09%2Fline-height%2F</url>
    <content type="text"><![CDATA[line-height 爱我你怕了吗 1. line-height的定义行高：两行文字基线（baseline）之间的距离 什么是基线 行高 行高可以让单行文本垂直居中？ 真的垂直居中了吗？ 2. line-height与行内框盒子模型 所有内联元素的样式表现都与行内框盒子模型有关 1&lt;p&gt;我是字&lt;em&gt;我是斜体字&lt;/em&gt;我是字我是我是字我是字我是字我是字我是字我是字我是字我是字&lt;/p&gt; 内容区域(content area),是一种围绕文字看不见的盒子。内容区域的大小与font-size有关 内联盒子(inline boxes)不会让内容显示成块，而是排成一行 ，如果外部含有标签属于内联盒子，如果仅仅是文本择属于匿名内联盒子 行框盒子(line boxes)，一行一个行框盒子，由内联盒子组成 包含盒子(containing boxes),由一行行的行框盒子组成 行内框盒子对line-height的现实意义 3.line-height 的各类属性值 normal 默认属性值，跟浏览器相关 且与字体类型有关 1.5 根据当前元素的font-size计算 1.5em 使用具体长度值作为行高值 150% 相对于设置了该行高属性元素的的的font-size大小计算 inherit 继承 4.line-height的高度机理 内容区域高度(content area)+行间距(vertical spacing) = 行高(line-height) 内容区域的高度只与字号和字体有关，与行高无关 内联元素的高度由内部的内容区域决定 inline-block 和块级元素的高度由内部内联元素的行高有关 一个inline-block元素，如果里面没有inline内联元素，或者overflow不是visible，则该元素的基线就是其margin底边缘，否则，其基线就是元素里面最后一行内联元素的基线。 宋体字体下内容区域的高度等于字体大小 更直观的例子 5. line-height 与 vertical-align 的关系123456789101112131415161718192021/* 关键字值 */vertical-align: baseline;vertical-align: sub;vertical-align: super;vertical-align: text-top;vertical-align: text-bottom;vertical-align: middle;vertical-align: top;vertical-align: bottom;/* &lt;长度&gt; 值 */vertical-align: 10em;vertical-align: 4px;/* &lt;百分比&gt; 值 */vertical-align: 10%;/* 全局值 */vertical-align: inherit;vertical-align: initial;vertical-align: unset; vertical-align的百分比值不是相对于字体大小或者其他什么属性计算的，而是相对于line-height计算的。举个简单的例子，如下CSS代码： 1234&#123; line-height: 30px; vertical-align: -10%;&#125; 等同于 1234&#123; line-height: 30px; vertical-align: -3px; /* = 30px * -10% */&#125; 真的垂直居中了吗？]]></content>
      <categories>
        <category>css basic</category>
      </categories>
      <tags>
        <tag>css基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css属性:背景与边框]]></title>
    <url>%2FBlog%2F2018%2F08%2F02%2Fborder%2F</url>
    <content type="text"><![CDATA[边框border 定义元素边框的外观特性1border：&lt;line-width&gt; || &lt;line-style&gt; || &lt;color&gt; border-width 定义元素的边框厚度1border-width:top right bottom left border-style 定义元素的边框样式 12345678910//可用取值hidden：隐藏边框。dotted：点状轮廓。ashed：虚线轮廓。solid：实线轮廓double：双线轮廓。两条单线与其间隔的和等于指定的border-width值groove：3D凹槽轮廓。ridge：3D凸槽轮廓。inset：3D凹边轮廓。outset：3D凸边轮廓。 border-color 定义元素的边框颜色 border-shadow 定义元素的阴影 12345678//可用取值none：无阴影&lt;length&gt;①：第 1 个长度值定义元素的阴影水平偏移值。正值，阴影出现在元素右侧；负值，则阴影出现在元素左侧&lt;length&gt;②：第 2 个长度值定义元素的阴影垂直偏移值。正值，阴影出现在元素底部；负值，则阴影出现在元素顶部&lt;length&gt;③：第 3 个长度值定义元素的阴影模糊值半径（如果提供了）。该值越大阴影边缘越模糊，若该值为0，阴影边缘不出现模糊。不允许负值&lt;length&gt;④：第 4 个长度值定义元素的阴影外延值（如果提供了）。正值，阴影将向四面扩展；负值，则阴影向里收缩&lt;color&gt;：定义元素阴影的颜色。如果该值未定义，阴影颜色将默认取当前最近的文本颜色inset：定义元素的阴影类型为内阴影。该值为空时，则元素的阴影类型为外阴影 结合伪类实现阴影 border-radius 定义元素的阴影 12345border-radius：&lt;length&gt; | &lt;percentage&gt;border-radius = border-top-left-radius, border-top-right-radius, border-bottom-right-radius, border-bottom-left-radius border-image 定义将图像应用到元素的边框上 12345678910border-image-source：定义元素边框背景图像，可以是图片路径或使用渐变创建的“背景图像”。border-image-slice：定义元素边框背景图像从什么位置开始分割。border-image-width：定义元素边框背景图像厚度。border-image-outset：定义元素边框背景图像的外延尺寸。border-image-repeat：定义元素边框背景图像的平铺方式。 背景background 定义元素的背景特性 一个元素可以设置多组背景图像，每组属性间使用逗号分隔。（背景色background-color不能设置多组，背景色通常都定义在最后一组上） 如果设置的多组背景图之间存在着交集（即存在着重叠关系），前面的背景图会覆盖在后面的背景图之上。 background-color 定义元素使用的背景颜色 背景图像会覆盖在背景颜色。 1background-color:transparent； //设置背景色透明 background-image 定义元素使用的背景图像 1渐变属性：inear-gradient, radial-gradient, repeating-linear-gradient, repeating-radial-gradient linear-gradient123456789101112下述值用来表示渐变的方向，可以使用角度或者关键字来设置：&lt;angle&gt;：用角度值指定渐变的方向（或角度）。to left：设置渐变为从右到左。相当于: 270degto right：设置渐变从左到右。相当于: 90degto top：设置渐变从下到上。相当于: 0degto bottom：设置渐变从上到下。相当于: 180deg。这是默认值，等同于留空不写。&lt;color-stop&gt; 用于指定渐变的起止颜色：&lt;color&gt;：指定颜色。&lt;length&gt;：用长度值指定起止色位置。不允许负值&lt;percentage&gt;：用百分比指定起止色位置。background-image:linear-gradient(135deg, #9DC3E6 0%, #F4B183 25%, #C9C9C9 50%, #FFD966 75%, #A9D18E 100%); 渐变图标 http://lea.verou.me/css3patterns/ background-repeat 定义元素的背景图像如何填充。 123456repeat-x：背景图像在横向上平铺repeat-y：背景图像在纵向上平铺repeat：背景图像在横向和纵向平铺no-repeat：背景图像不平铺round：当背景图像不能以整数次平铺时，会根据情况缩放图像。（CSS3）space：当背景图像不能以整数次平铺时，会用空白间隙填充在图像周围。（CSS3） background-attachment 定义滚动时背景图像相对于谁固定 123fixed：背景图像相对于视口（viewport）固定。scroll：背景图像相对于元素固定，也就是说当元素内容滚动时背景图像不会跟着滚动，因为背景图像总是要跟着元素本身。但会随元素的祖先元素或窗体一起滚动。local：背景图像相对于元素内容固定，也就是说当元素随元素滚动时背景图像也会跟着滚动，因为背景图像总是要跟着内容。（CSS3） background-position 指定背景图像在元素中出现的位置 12345678910&lt;percentage&gt;：用百分比指定背景图像在元素中出现的位置。可以为负值。参考容器尺寸减去背景图尺寸进行换算。&lt;length&gt;：用长度值指定背景图像在元素中出现的位置。可以为负值。center：背景图像横向或纵向居中。left：背景图像从元素左边开始出现。right：背景图像从元素右边开始出现。top：背景图像从元素顶部开始出现。bottom：背景图像从元素底部开始出现。示例：假设要定义背景图像在容器中右下方，并且距离右边和底部各有20pxbackground: url(test1.jpg) no-repeat right 20px bottom 20px; 雪碧图 https://www.toptal.com/developers/css/sprite-generator .icon2{background-position: -40px -40;} background-origin 指定的背景图像计算background-position时的参考原点(位置) 123border-box从border区域（含border）开始显示背景图像。padding-box：从padding区域（含padding）开始显示背景图像。content-box：从content区域开始显示背景图像。 background-clip 指定对象的背景图像向外裁剪的区域 1234border-box：从border区域（含border）开始向外裁剪背景。padding-box：从padding区域（含padding）开始向外裁剪背景。content-box：从content区域开始向外裁剪背景。text：从前景内容的形状（比如文字）作为裁剪区域向外裁剪，如此即可实现使用背景作为填充色之类的遮罩效果。 文字遮罩 http://demo.doyoe.com/css3/background-clip/mask-text2.htmbackground-size 定义背景图像的尺寸大小 12345&lt;length&gt;：用长度值指定背景图像大小。不允许负值。&lt;percentage&gt;：用百分比指定背景图像大小。不允许负值。auto：背景图像的真实大小。cover：将背景图像等比缩放到完全覆盖容器，背景图像有可能超出容器。contain：将背景图像等比缩放到宽度或高度与容器的宽度或高度相等，背景图像始终被包含在容器内]]></content>
      <categories>
        <category>css basic</category>
      </categories>
      <tags>
        <tag>css基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css属性:表格table]]></title>
    <url>%2FBlog%2F2018%2F08%2F01%2Ftable%2F</url>
    <content type="text"><![CDATA[table-layout: fixed : 固定布局 auto： 自动算法 See the Pen table-layout by liuzhaozhao828 (@liuzhaozhao) on CodePen. border-collapse: collapse: 相邻边框合并 separate: 边框独立 See the Pen border-collapse by liuzhaozhao828 (@liuzhaozhao) on CodePen. border-spacing: 只在boder-collapse为 separate的情况下有效果 复合属性，横向相邻和纵向相邻分开设置：border-spacing：10px 20px IE6/7无效，兼容方式&lt;table border=&quot;1&quot; cellspacing=&quot;20&quot;&gt; See the Pen border-spacing by liuzhaozhao828 (@liuzhaozhao) on CodePen. caption-side: caption的位置 取值 top bottom left right (只有Firefox支持) See the Pen caption-side by liuzhaozhao828 (@liuzhaozhao) on CodePen. empty-cells: 取值 hide show 单元格没值时，隐藏边框 只在boder-collapse为 separate的情况下有效果 See the Pen empty-cells by liuzhaozhao828 (@liuzhaozhao) on CodePen.]]></content>
      <categories>
        <category>css basic</category>
      </categories>
      <tags>
        <tag>css基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css属性:尺寸与补白]]></title>
    <url>%2FBlog%2F2018%2F08%2F01%2Fdimension%2F</url>
    <content type="text"><![CDATA[尺寸Dimension用于控制元素的高度和宽度，包含属性有width、height、min-width、max-height、max-width、max-height; 语法&lt;length&gt; | &lt;percentage&gt; | auto默认值为auto 适用于：除非置换内联元素，table-row, table-row-group之外的所有元素width height设置或检索对象的宽度和高度 对于img对象来说，仅指定一个尺寸属性，另一值将根据图片源尺寸等比例缩放；特殊的比如iframe, canvas，当width的计算值为auto时，则宽度的使用值为300px,height为auto时,高度的使用值为150px。 See the Pen 尺寸 by Fengguangnan (@fengguangnan) on CodePen. min-width min-height设置或检索对象的最小宽度和最小高度max-width max-height 设置或检索对象的最大宽度和最大高度 min-* 值小于width(height)时，min-*会被忽略、大于width(height)时，min-*属性将会被忽略，同时width(height)会忽略自己的值定义而使用min-*的值作为自己的使用值； max-* 值小于width(height)时，会被忽略，同时width(height)会忽略自己的值定义而使用max-*的值作为自己的使用值、值大于width(height)时，max-*属性将会被忽略； 如果min-*属性的值大于max-*属性的值，max-*将会自动以min-*的值作为自己的值。 See the Pen 尺寸 by Fengguangnan (@fengguangnan) on CodePen. 补白margin(外补白)指从自身边框到另一个容器边框之间的距离，就是容器外距离语法[ &lt;length&gt; | &lt;percentage&gt; | auto ]{1,4} 取值：auto：水平（默认）书写模式下，margin-top/margin-bottom计算值为0，margin-left/margin-right取决于可用空间 &lt;length&gt;： 用长度值来定义margin。==可以为负值== &lt;percentage&gt;：用百分比来定义外补白。水平（默认）书写模式下，参照其父元素的 width 进行计算，其它情况参照 height ，==可以为负值 == 如果提供全部四个参数值顺序顺序 margin:top、right、bottom、left; 适用于：所有元素，除非 table | inline-table | table-caption 的表格类元素之外 属性值也可以拆分成四个：margin-top、margin-right、margin-bottom、margin-leftmargin-top、margin-bottom:非置换内联元素要使用该属性必须转为块级或行内块级 See the Pen margin by Fengguangnan (@fengguangnan) on CodePen. padding(内补白)指自身边框到自身内部另一个容器边框之间的距离，就是容器内距离。 语法[ &lt;length&gt; | &lt;percentage&gt;]{1,4} 取值：&lt;length&gt;：用长度值来定义内补白。==不允许负值==&lt;percentage&gt;：用百分比来定义内补白。水平（默认）书写模式下，参照其包含块 width 进行计算，其它情况参照 height 。==不允许负值== 如果提供全部四个参数值顺序与margin相同:top、right、bottom、left; 适用于：所有元素，除 table-row-group | table-header-group | table-footer-group | table-column-group | table-row 外 属性值也可以拆分成四个：padding-top、padding-right、padding-bottom、padding-left 给行内元素定义纵向内补白（padding-top/padding-bottom）时，虽然不需要将之转化为行内块或者块级，但是给行内元素设置纵向内补白并不会影响布局。内补白会在当前元素的行框基础上向顶部和顶部外延， See the Pen padding by Fengguangnan (@fengguangnan) on CodePen.]]></content>
      <categories>
        <category>css basic</category>
      </categories>
      <tags>
        <tag>css基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css属性:布局layout]]></title>
    <url>%2FBlog%2F2018%2F07%2F31%2Flayout%2F</url>
    <content type="text"><![CDATA[display none： 1.不展示 2.不占物理空间（区别visibility：hidden) inline： 1.内联元素 2.Line-height:可以设置内联元素的高度 3.Margin: 内联非替换元素margin-top, margin-bottom无效 See the Pen display-1 by liuzhaozhao828 (@liuzhaozhao) on CodePen. 4.Padding: 父元素未指宽高，内联非替换不会撑高父元素，内联替换会撑高父元素 See the Pen display-2 by liuzhaozhao828 (@liuzhaozhao) on CodePen. block： 1.块元素 2.独占一行 inline-block： 1.内联块元素 2.内联块之间有缝隙 回车字符占用了4px，解决方法：父元素设置 font-size: 0 table系属性值 1.table：块元素级的表格，相当于标签&lt;table&gt; 2.inline-table：内联元素级的表格，相当于标签&lt;table&gt; 3.table-caption：表格标题，相当于标签&lt;caption&gt; 4.table-cell：表格单元格，相当于标签&lt;td&gt; 5.table-row：指定对象作为表格行，相当于标签&lt;tr&gt; 6.table-row-group：表格行组，相当于标签&lt;tbody&gt; 7.table-column：表格列，相当于标签&lt;col&gt; 8.table-column-group：表格列组显示，相当于标签&lt;colgroup&gt; 9.table-header-group：表格标题组，相当于标签&lt;thead&gt; 10.table-footer-group：表格脚注组，相当于标签&lt;tfoot&gt; 其他： 1.list-item：列表项目 2.run-in:根据上下文决定是内联还是块, chrome不支持 visibility 取值： visible hidden hidden隐藏元素，但是保留物理空间 clear 取值： both left right float 取值： none，left， right 特性： 1.脱离文档流 2.变为块元素 清除浮动的三种办法： 1.增加div元素，该元素通过clear属性清除浮动 2.增加伪元素:after，通过clear属性清除浮动 3.父元素增加属性overflow:hidden，生成BFC清除浮动 See the Pen float-clear by liuzhaozhao828 (@liuzhaozhao) on CodePen. overflow 取值：visible, hidden，scroll, auto overflow等同于 overflow-x overflow-y 值为非visibile时，将会为它的内容创建一个新的块格式化上下文（BFC）]]></content>
      <categories>
        <category>css basic</category>
      </categories>
      <tags>
        <tag>css基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css属性:position]]></title>
    <url>%2FBlog%2F2018%2F07%2F25%2Fpositions%2F</url>
    <content type="text"><![CDATA[postion用于指定一个元素在文档中的定位方式 使用语法支持属性static | relative | absolute | fixed | sticky,其中默认值为static注意，position 属性只针对display不为table-column-group | table-column的元素生效 static默认值,left、top、bottom、right四个定位属性不会生效 relative对象遵循常规流，并且参照自身在常规流中的位置通过top，right，bottom，left这4个定位偏移属性进行偏移时不会影响常规流中的任何元素。 See the Pen position_relative by scliuyang (@scliuyang) on CodePen. absolute对象脱离常规流，此时偏移属性参照的是离自身最近的定位祖先元素，如果没有定位的祖先元素(或者说祖先元素都是position:static)，则一直回溯到window也就是整个窗口元素。盒子的偏移位置不影响常规流中的任何元素，其margin不与其他任何margin折叠(这里是由于创建了BFC，块级格式化上下文导致的，推荐阅读深入理解BFC和Margin Collapse)。他跟relative最大的区别就是脱离文档流，也就是说相邻元素会无视并占据它所在的位置 See the Pen position_absolute by scliuyang (@scliuyang) on CodePen. fixed与absolute一致，但偏移定位是以窗口为参考。当出现滚动条时，对象不会随着滚动。 sticky对象在常态时遵循常规流。它就像是relative和fixed的合体，当在屏幕中时按常规流排版，当卷动到屏幕外时则表现如fixed。该属性的表现是现实中你见到的吸附效果 See the Pen position_sticky by scliuyang (@scliuyang) on CodePen. 不过这属性兼容性不咋的 定位属性top/bottom支持属性auto | &lt;length&gt; | &lt;percentage&gt;,默认值为auto,仅在position非static时生效 auto：无特殊定位，根据HTML定位规则在文档流中分配 ：用长度值来定义距离顶部的偏移量。可以为负值。 ：用百分比来定义距离顶部的偏移量。百分比参照包含块的高度。可以为负值。 在relative时,auto计算值为0,如果top和bottom其中一个为auto，则auto相当于另一个的负值，即top = -bottom；如果top和bottom的值都不为auto，则忽略bottom。在absolute时,auto计算为元素的正常文档流位置,如果top和bottom都设值会设置元素的高度，相当于离包含块的顶部和底部多少距离 See the Pen absolute_top_bttom by scliuyang (@scliuyang) on CodePen. left/right和top/bottom基本一致，只是percentage计算参照的是包含块的宽度 demo水平垂直居中 See the Pen 水平垂直居中 by scliuyang (@scliuyang) on CodePen. clip(被废弃，clip-path取代) rect(|auto |auto |auto |auto)：依据上-右-下-左的顺序提供自对象左上角为(0,0)坐标计算的四个偏移数值，其中任一数值都可用auto替换，即此边不剪切。必须设置absolute或者fixed才会生效，没有clip-path好用 See the Pen clip by scliuyang (@scliuyang) on CodePen.]]></content>
      <categories>
        <category>css basic</category>
      </categories>
      <tags>
        <tag>css基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css属性:列表list]]></title>
    <url>%2FBlog%2F2018%2F07%2F25%2Flist%2F</url>
    <content type="text"><![CDATA[列表 list给 li 或者 display:list-item 的元素设置样式 list-style复合属性list-style：&lt;&#39; list-style-type &#39;&gt; || &lt;&#39; list-style-position &#39;&gt; || &lt;&#39; list-style-image &#39;&gt; list-style-type设置列表样式,取值 disc：实心圆(CSS1) circle：空心圆(CSS1) square：实心方块(CSS1) decimal：阿拉伯数字(CSS1) lower-roman：小写罗马数字(CSS1) upper-roman：大写罗马数字(CSS1) lower-alpha：小写英文字母(CSS1) upper-alpha：大写英文字母(CSS1) none：不使用项目符号(CSS1) armenian：传统的亚美尼亚数字(CSS2) cjk-ideographic：浅白的表意数字(CSS2) georgian：传统的乔治数字(CSS2) lower-greek：基本的希腊小写字母(CSS2) hebrew：传统的希伯莱数字(CSS2) hiragana：日文平假名字符(CSS2) hiragana-iroha：日文平假名序号(CSS2) katakana：日文片假名字符(CSS2) katakana-iroha：日文片假名序号(CSS2) lower-latin：小写拉丁字母(CSS2) upper-latin：大写拉丁字母(CSS2) 仅当list-style-image属性为none或指定图像不可用时才生效 See the Pen list-type by scliuyang (@scliuyang) on CodePen. list-style-image设置样式为图片，取值 none:不指定图像，默认内容标记将被 &lt;’ list-style-type ‘&gt; 代替。 url:使用绝对或相对地址指定列表项标记图像。如果图像地址无效，默认内容标记将被 &lt;’ list-style-type ‘&gt; 代替。 See the Pen list-img by scliuyang (@scliuyang) on CodePen. list-style-position设置或检索作为对象的列表项标记如何根据文本排列。取值 outside: 列表项目标记放置在文本以外，且环绕文本不根据标记对齐 inside: 列表项目标记放置在文本以内，且环绕文本根据标记对齐 See the Pen list-position by scliuyang (@scliuyang) on CodePen.]]></content>
      <categories>
        <category>css basic</category>
      </categories>
      <tags>
        <tag>css基础</tag>
      </tags>
  </entry>
</search>
